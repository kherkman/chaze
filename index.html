<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaze</title>
    <style>
        /* --- Basic Page Setup --- */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #333; /* Dark grey background */
            color: white; /* White text */
            display: flex; /* Use flexbox for centering */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            height: 100vh; /* Full viewport height */
            overflow: hidden; /* Hide scrollbars */
        }

        /* --- Scalable Container for Resolution Independence --- */
        /* This container holds the entire game and is scaled with JavaScript to fit the user's screen. */
        #scalable-content {
            width: 1280px; /* Native resolution width */
            height: 900px; /* Native resolution height */
            position: relative;
            transform-origin: center center; /* Scale from the center */
        }

        /* --- Start and Game Over Screens --- */
        /* These screens overlay the game area. */
        #startScreen, #gameOverScreen {
            text-align: center;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex; /* Use flexbox for content alignment */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85); /* Semi-transparent black background */
            z-index: 100; /* Ensure they appear on top of the game */
        }

        #startScreen h1, #gameOverScreen h1 {
            font-size: 8vw;
            margin-bottom: 20px;
        }

        #startScreen p {
            font-size: 1.8vw;
        }
        
        #gameOverScreen p {
            font-size: 3vw;
            color: #ffc107; /* Amber color for the winner info */
            margin-bottom: 30px;
        }

        #gameOverScreen span {
            font-size: 1.5vw;
            color: #ccc; /* Light grey for helper text */
        }

        #playerCount, #startButton, #botDifficulty {
            font-size: 1.5em;
            margin: 10px;
            padding: 10px;
        }
        
        /* --- Main Game Container --- */
        #gameContainer {
            display: none; /* Initially hidden until the game starts */
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        
        /* --- Top Information Area (Turn, Controls, Rules) --- */
        #info-area {
            width: 800px;
            text-align: center;
            margin-top: 20px;
        }

        /* Container for turn display and action buttons */
        #gameInfo {
            display: flex;
            justify-content: space-between; /* Space out the items */
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
            font-size: 1.2em;
        }
        
        /* Buttons for switching between moving and rotating */
        #action-controls button {
            font-size: 1em;
            padding: 10px 15px;
            margin: 0 5px;
            border: 2px solid #aaa;
            background-color: #555;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
        }
        
        /* Style for the currently active button */
        #action-controls button.active {
            background-color: #ddd;
            color: #333;
            border-color: #fff;
        }

        /* Displays whose turn it is */
        #turn-display {
            font-weight: bold;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px #000;
        }
        
        /* Displays moves left in the current turn */
        #moves-counter {
            font-size: 1.1em;
            color: #ccc;
            margin-top: 5px;
        }
        
        /* Displays the "rock-paper-scissors" eating rules */
        #rules-display {
            margin-top: 10px;
            margin-bottom: 20px;
            padding: 5px;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.2);
            font-size: 1.1em;
            color: #ddd;
            text-align: center;
        }

        #rules-display span {
            font-weight: bold;
            font-size: 1.5em;
            vertical-align: middle;
            display: inline-block;
            margin: 0 5px;
        }

        /* --- Board and Pieces Area --- */
        #board-container {
            position: relative; /* Needed for absolute positioning of bases and graveyards */
            width: 614px;
            height: 614px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Player's starting area (home base) */
        .base {
            position: absolute; /* Positioned outside the main board */
            width: 150px; 
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            z-index: 10;
            pointer-events: none; /* Allows clicks to pass through the container itself */
        }

        /* Positioning for each player's base in the corners */
        #player1-base { top: -100px; left: -100px; }
        #player2-base { top: -100px; right: -100px; }
        #player3-base { bottom: -100px; left: -100px; }
        #player4-base { bottom: -100px; right: -100px; }

        .base-square {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            pointer-events: auto; /* Makes the individual squares clickable again */
        }

        /* NEW RULE: Ensures pieces in the base are the same size as on the board. */
        .base-square .piece {
            font-size: 1.8em;
        }

        /* Colors for each player's base */
        #player1-base .base-square { background-color: cyan; }
        #player2-base .base-square { background-color: yellow; }
        #player3-base .base-square { background-color: magenta; }
        #player4-base .base-square { background-color: green; }
        
        /* Area where captured pieces go */
        .graveyard {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
            width: 60px;
            height: 200px;
            border: 2px dashed #777;
            border-radius: 5px;
            z-index: 20;
        }
        
        /* Positioning for each player's graveyard */
        #player1-graveyard { top: -100px; left: -200px; }
        #player2-graveyard { top: -100px; right: -200px; }
        #player3-graveyard { bottom: -100px; left: -200px; }
        #player4-graveyard { bottom: -100px; right: -200px; }


        .graveyard .piece {
            width: 45px;
            height: 45px;
            font-size: 1.8em; /* MODIFIED RULE: Makes graveyard pieces same size as on board. */
            cursor: not-allowed; /* Indicates these pieces cannot be moved */
            opacity: 0.6; /* Faded appearance for captured pieces */
        }
        /* Hide the move counter on captured pieces */
        .graveyard .piece .move-counter { display: none; }


        /* The main 3x3 grid of major squares */
        #game-board {
            display: grid;
            width: 600px;
            height: 600px;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            background-color: #666;
            padding: 5px;
            border: 2px solid #999;
        }

        /* Each of the 9 large squares, which can be rotated */
        .main-square {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            background-color: white;
        }

        /* Each of the 81 small squares where pieces can be placed */
        .sub-square {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em; /* This determines the size of the piece symbol on the board */
            font-weight: bold;
            cursor: pointer;
        }
        
        /* Impassable squares */
        .wall {
            background-color: #5a5a5a;
            cursor: not-allowed;
        }
        
        /* --- General Piece Styling --- */
        .piece {
            position: relative; /* For positioning the move counter */
            border-radius: 50%; /* Makes the piece circular */
            width: 80%;
            height: 80%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: black;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4); /* Adds depth */
            cursor: grab; /* Indicates the piece can be dragged */
            box-sizing: border-box; /* Ensures border is included in width/height calculation */
        }
        
        /* Style for a piece being dragged */
        .piece.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        /* Style for a piece that is selected for a click-to-move action */
        .piece.selected {
            border: 4px solid white; /* White outline when selected */
        }

        /* Small number on the piece showing moves this turn */
        .move-counter {
            position: absolute;
            bottom: 1px;
            right: 4px;
            font-size: 0.5em; /* Relative to the piece's font-size */
            font-weight: bold;
            background: rgba(255, 255, 255, 0.7);
            color: black;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Message Overlay --- */
        /* Used for temporary messages like "Path is blocked". */
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: none; /* Let clicks pass through to the game */
        }

        #message-overlay p {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 2.5em;
            color: white;
            text-shadow: 2px 2px 5px #000;
        }

        /* --- Player-Specific Colors --- */
        .player1 { background-color: cyan; }
        .player2 { background-color: yellow; }
        .player3 { background-color: magenta; }
        .player4 { background-color: green; }

        /* --- Mobile / Portrait View Styling --- */
        @media (orientation: portrait) {
            #startScreen, #gameOverScreen {
                padding: 0 15px;
                box-sizing: border-box;
            }

            #startScreen h1, #gameOverScreen h1 {
                font-size: 12vw;
                margin-bottom: 2vh;
            }

            #startScreen p {
                font-size: 3.5vw;
                line-height: 1.4;
                margin: 1.5vh 0;
            }
            
            #gameOverScreen p {
                font-size: 5vw;
                margin-bottom: 3vh;
            }

            #gameOverScreen span {
                font-size: 3.5vw;
            }
        }

    </style>
</head>
<body>
    <!-- The initial screen with game title and player selection -->
    <div id="startScreen">
        <h1>CHAZE</h1>
        <p>A blend of chess, maze and rock-paper-scissors.<br>
        The "<span id="p-plus"></span>" piece moves any number of squares horizontally or vertically.<br>
        The "<span id="p-star"></span>" piece can move any number of squares horizontally, vertically, or diagonally.<br>
        The "<span id="p-x"></span>" piece moves any number of squares diagonally.</p>
        <label for="playerCount">Select Number of Players:</label>
        <select id="playerCount">
            <option value="1">1 Player (vs Bot)</option>
            <option value="2">2 Players</option>
            <option value="3">3 Players</option>
            <option value="4">4 Players</option>
        </select>
        <label for="botDifficulty" style="display: block;">Bot Difficulty:</label>
        <select id="botDifficulty" style="display: block;">
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard">Hard</option>
        </select>
        <button id="startButton">Start Game</button>
    </div>

     <!-- The screen shown when the game ends -->
     <div id="gameOverScreen" style="display: none;">
        <h1>Game Over</h1>
        <p id="winner-info"></p>
        <span>Click anywhere to Play Again</span>
    </div>

    <div id="scalable-content">
        <!-- An overlay for showing temporary messages to the user -->
        <div id="message-overlay">
            <p id="message-text"></p>
        </div>

        <!-- The main container for the game board and UI -->
        <div id="gameContainer">
            <!-- Top section with turn info, controls, and rules -->
            <div id="info-area">
                <div id="gameInfo">
                    <div id="turn-display">Turn: Player 1</div>
                     <div id="action-controls">
                        <button id="movePieceBtn" class="active">Move a Piece</button>
                        <button id="rotateSquareBtn">Rotate a Square</button>
                    </div>
                    <div id="turn-counter">Turn #: 1</div>
                </div>
                <div id="moves-counter">Moves Made: 0 / 2</div>
                <div id="rules-display">
                     <span id="rule-plus-1"></span> eats <span id="rule-x-1"></span> &nbsp;&nbsp;|&nbsp;&nbsp; <span id="rule-x-2"></span> eats <span id="rule-star-1"></span> &nbsp;&nbsp;|&nbsp;&nbsp; <span id="rule-star-2"></span> eats <span id="rule-plus-2"></span>
                </div>
            </div>
            <!-- Central area containing the board and surrounding player areas -->
            <div id="board-container">
                <!-- Graveyards for captured pieces -->
                <div id="player1-graveyard" class="graveyard"></div>
                <div id="player2-graveyard" class="graveyard"></div>
                <div id="player3-graveyard" class="graveyard"></div>
                <div id="player4-graveyard" class="graveyard"></div>
                <!-- Bases for starting pieces -->
                <div id="player1-base" class="base"></div>
                <div id="player2-base" class="base"></div>
                <div id="player3-base" class="base"></div>
                <div id="player4-base" class="base"></div>
                <!-- The game board itself -->
                <div id="game-board"></div>
            </div>
        </div>
    </div>

    <script>
        // Wait until the entire HTML document is loaded and parsed before running the script.
        document.addEventListener('DOMContentLoaded', () => {
            // --- Symbol Configuration ---
            // This is the single source of truth for piece symbols.
            // Change the character on the right to change the piece's appearance everywhere.
            const pieceSymbols = {
                "plus-piece": "⊕",
                "star-piece": "✴",
                "x-piece": "𐅡"
            };

            // --- DOM Element References ---
            const scalableContent = document.getElementById('scalable-content');
            const NATIVE_WIDTH = 1280; // The original design width
            const NATIVE_HEIGHT = 900; // The original design height

            // --- Game Scaling Logic ---
            // This function scales the game content to fit the browser window while maintaining aspect ratio.
            function scaleGame() {
                const availableWidth = window.innerWidth;
                const availableHeight = window.innerHeight;
                const scale = Math.min(availableWidth / NATIVE_WIDTH, availableHeight / NATIVE_HEIGHT);
                scalableContent.style.transform = `scale(${scale})`;
            }

            // Scale the game initially and add a listener to rescale on window resize.
            scaleGame();
            window.addEventListener('resize', scaleGame);

            // --- UI Element References ---
            const startButton = document.getElementById('startButton');
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const winnerInfo = document.getElementById('winner-info');
            const messageOverlay = document.getElementById('message-overlay');
            const messageText = document.getElementById('message-text');
            const gameContainer = document.getElementById('gameContainer');
            const playerCountSelect = document.getElementById('playerCount');
            const botDifficultySelect = document.getElementById('botDifficulty');
            const botDifficultyLabel = document.querySelector('label[for="botDifficulty"]');
            const gameBoard = document.getElementById('game-board');
            const turnDisplay = document.getElementById('turn-display');
            const turnCounterDisplay = document.getElementById('turn-counter');
            const movesCounterDisplay = document.getElementById('moves-counter');
            const movePieceBtn = document.getElementById('movePieceBtn');
            const rotateSquareBtn = document.getElementById('rotateSquareBtn');

            // --- Game State Variables ---
            let numPlayers; // Total number of players in the game (2, 3, or 4)
            let isBotGame; // Boolean flag for 1-player mode against AI
            let botDifficulty = 'easy'; // Bot difficulty setting
            let currentPlayer = 1; // The player whose turn it is
            let turnCount = 1; // The overall turn number
            let movesLeft = 2; // Actions remaining in the current turn
            let draggedPiece = null; // Reference to the piece element being dragged
            let selectedPiece = null; // Reference to the piece element selected for click-to-move
            let pieceMovedTwice = null; // Tracks if a single piece has been moved to enforce the "one piece moved twice or two pieces moved once" rule
            let currentAction = 'move'; // The currently selected action ('move' or 'rotate')
            let activePlayers = []; // An array of player numbers who are still in the game
            let messageTimeout; // A timer for hiding the message overlay
            let isGameOver = false; // Flag to stop actions after the game has ended

            const playerColors = { 1: 'cyan', 2: 'yellow', 3: 'magenta', 4: 'green' };
            // The pieceTypes array now uses the internal names. The order defines the piece creation order.
            const pieceTypes = ["plus-piece", "x-piece", "star-piece"];
            // The pieceValues object uses the internal names as keys.
            const pieceValues = { "plus-piece": 3, "star-piece": 2, "x-piece": 1 }; // Values for AI and stalemate
            let players = {}; // An object to store data for each player's pieces
            
            // This function populates the symbols in the static HTML from the config object.
            function populateSymbols() {
                // Start Screen
                document.getElementById('p-plus').textContent = pieceSymbols['plus-piece'];
                document.getElementById('p-star').textContent = pieceSymbols['star-piece'];
                document.getElementById('p-x').textContent = pieceSymbols['x-piece'];

                // Rules Display
                document.getElementById('rule-plus-1').textContent = pieceSymbols['plus-piece'];
                document.getElementById('rule-plus-2').textContent = pieceSymbols['plus-piece'];
                document.getElementById('rule-x-1').textContent = pieceSymbols['x-piece'];
                document.getElementById('rule-x-2').textContent = pieceSymbols['x-piece'];
                document.getElementById('rule-star-1').textContent = pieceSymbols['star-piece'];
                document.getElementById('rule-star-2').textContent = pieceSymbols['star-piece'];
            }
            populateSymbols(); // Call on script load

            // --- Core Game Flow Functions ---
            
            // Show/hide bot difficulty based on player count
            function toggleBotDifficulty() {
                const isVisible = playerCountSelect.value === '1';
                botDifficultySelect.style.display = isVisible ? 'block' : 'none';
                botDifficultyLabel.style.display = isVisible ? 'block' : 'none';
            }
            playerCountSelect.addEventListener('change', toggleBotDifficulty);
            toggleBotDifficulty(); // Initial check

            // Attempts to put the browser into fullscreen mode.
            function enterFullScreen() {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
            }

            // Displays a message on the overlay for a set duration.
            function showMessage(message, duration = 2000) {
                clearTimeout(messageTimeout); // Clear any existing message timer
                messageText.textContent = message;
                messageOverlay.style.display = 'flex';
                messageTimeout = setTimeout(() => {
                    messageOverlay.style.display = 'none';
                }, duration);
            }

            // Hides the game and shows the game over screen with a winner message.
            function showGameOverScreen(message) {
                 isGameOver = true; // Set the game over flag
                 setTimeout(() => { // Small delay to allow the final move to be seen
                    winnerInfo.textContent = message;
                    gameContainer.style.display = 'none';
                    gameOverScreen.style.display = 'flex';
                }, 500);
            }

            // Event listener to return to the start screen from the game over screen.
            gameOverScreen.addEventListener('click', () => {
                gameOverScreen.style.display = 'none';
                startScreen.style.display = 'flex';
            });

            // Event listener for the "Start Game" button.
            startButton.addEventListener('click', () => {
                numPlayers = parseInt(playerCountSelect.value);
                isBotGame = numPlayers === 1;
                if (isBotGame) {
                    numPlayers = 2; // If it's a bot game, set up for 2 players
                    botDifficulty = botDifficultySelect.value;
                }

                startScreen.style.display = 'none';
                gameContainer.style.display = 'flex';
                enterFullScreen();
                initializeGame();
            });

            // --- Game Initialization ---
            // Sets up the game board, pieces, and resets all state variables. Called at the start of a new game.
            function initializeGame() {
                // Reset game state
                isGameOver = false;
                activePlayers = [];
                currentPlayer = 1;
                turnCount = 1;
                movesLeft = 2;
                pieceMovedTwice = null;
                for (let i = 1; i <= numPlayers; i++) {
                    activePlayers.push(i);
                }
                
                // Clear the board and player areas for restart scenarios
                gameBoard.innerHTML = '';
                for (let i = 1; i <= 4; i++) {
                    const base = document.getElementById(`player${i}-base`);
                    const graveyard = document.getElementById(`player${i}-graveyard`);
                    if(base) base.innerHTML = '';
                    if(graveyard) graveyard.innerHTML = '';
                }

                // --- Board Generation ---
                // Create the 9 main squares, each containing 9 sub-squares.
                for (let i = 0; i < 9; i++) {
                    const mainSquare = document.createElement('div');
                    mainSquare.classList.add('main-square');
                    mainSquare.dataset.mainSquareId = i; // For rotation tracking
                    for (let j = 0; j < 9; j++) {
                        const subSquare = document.createElement('div');
                        subSquare.classList.add('sub-square');
                        subSquare.dataset.mainSquare = i; // Store parent square ID
                        subSquare.dataset.subSquare = j;  // Store local square ID
                        mainSquare.appendChild(subSquare);
                    }
                    gameBoard.appendChild(mainSquare);

                    // --- Wall Generation (within each main square) ---
                    // Randomly places 3 walls in each 3x3 main square.
                    const subSquares = Array.from(mainSquare.children);
                    // Map of each sub-square index to its adjacent neighbors.
                    const neighborsMap = {
                        0: [1, 3], 1: [0, 2, 4], 2: [1, 5],
                        3: [0, 4, 6], 4: [1, 3, 5, 7], 5: [2, 4, 8],
                        6: [3, 7], 7: [4, 6, 8], 8: [5, 7]
                    };

                    const walls = [];
                    // Pick the first wall completely randomly.
                    let s1_idx = Math.floor(Math.random() * 9);
                    walls.push(s1_idx);

                    // Pick the second wall from the neighbors of the first.
                    let s2_options = neighborsMap[s1_idx];
                    let s2_idx = s2_options[Math.floor(Math.random() * s2_options.length)];
                    walls.push(s2_idx);
                    
                    // Pick the third wall from the combined neighbors of the first two, ensuring it's not one of them.
                    let s3_options = [...new Set([...neighborsMap[s1_idx], ...neighborsMap[s2_idx]])];
                    s3_options = s3_options.filter(idx => !walls.includes(idx));
                    let s3_idx = s3_options[Math.floor(Math.random() * s3_options.length)];
                    walls.push(s3_idx);

                    // Add the 'wall' class to the selected sub-squares.
                    walls.forEach(wallIndex => {
                        subSquares[wallIndex].classList.add('wall');
                    });
                }

                // --- Piece and Player Area Generation ---
                for (let i = 1; i <= 4; i++) {
                    players[i] = []; // Initialize the player's piece array
                    const base = document.getElementById(`player${i}-base`);
                    const graveyard = document.getElementById(`player${i}-graveyard`);
                    
                    // If the player is not in the current game, hide their areas.
                    if (i > numPlayers) {
                        base.style.display = 'none';
                        graveyard.style.display = 'none';
                        continue;
                    }
                     base.style.display = 'grid';
                     graveyard.style.display = 'flex';
                    
                    const pieces = [];
                    // Create 3 pieces for the player.
                    for (let j = 0; j < 3; j++) {
                        const baseSquare = document.createElement('div');
                        baseSquare.classList.add('base-square');
                        const pieceElement = document.createElement('div');
                        pieceElement.classList.add('piece', `player${i}`);
                        const pieceType = pieceTypes[j]; // Get internal name
                        pieceElement.textContent = pieceSymbols[pieceType]; // Set display symbol
                        pieceElement.dataset.player = i;
                        pieceElement.dataset.type = pieceType; // Store internal name
                        pieceElement.draggable = true;
                        
                        // Create the move counter element for the piece.
                        const moveCounter = document.createElement('div');
                        moveCounter.classList.add('move-counter');
                        moveCounter.textContent = '0';
                        pieceElement.appendChild(moveCounter);

                        // Store piece data in the global 'players' object for easy access.
                        players[i].push({ 
                            player: i, 
                            type: pieceType, 
                            element: pieceElement,
                            movesThisTurn: 0 
                        });
                        baseSquare.appendChild(pieceElement);
                        pieces.push(baseSquare);
                    }

                    // Arrange pieces in the base with one empty square.
                    const blankDiv = () => document.createElement('div');
                    switch (i) {
                        case 1: 
                            base.appendChild(pieces[0]); base.appendChild(pieces[1]);
                            base.appendChild(pieces[2]); base.appendChild(blankDiv());
                            break;
                        case 2:
                            base.appendChild(pieces[0]); base.appendChild(pieces[1]);
                            base.appendChild(blankDiv()); base.appendChild(pieces[2]);
                            break;
                        case 3:
                            base.appendChild(pieces[0]); base.appendChild(blankDiv());
                            base.appendChild(pieces[1]); base.appendChild(pieces[2]);
                            break;
                        case 4:
                            base.appendChild(blankDiv()); base.appendChild(pieces[0]);
                            base.appendChild(pieces[1]); base.appendChild(pieces[2]);
                            break;
                    }
                }
                
                // Set up all necessary event listeners and update the UI.
                addEventListeners();
                updateTurnDisplay();
                updateMovesDisplay();
                turnCounterDisplay.textContent = `Turn #: ${turnCount}`;
            }

            // --- Event Listener Setup ---
            function addEventListeners() {
                // Main listeners for clicks and action buttons.
                gameContainer.addEventListener('click', handleGameClick);
                movePieceBtn.addEventListener('click', () => setAction('move'));
                rotateSquareBtn.addEventListener('click', () => setAction('rotate'));

                // --- Drag and Drop Logic ---
                gameContainer.addEventListener('dragstart', (e) => {
                    // Only allow dragging if it's a piece, the action is 'move', and it's the current player's piece.
                    if (currentAction !== 'move' || !e.target.classList.contains('piece')) {
                        e.preventDefault();
                        return;
                    }
                    if (parseInt(e.target.dataset.player) !== currentPlayer) {
                         e.preventDefault();
                         return;
                    }

                    draggedPiece = e.target;
                    if (selectedPiece) { // Deselect any piece selected for click-to-move
                        selectedPiece.classList.remove('selected');
                        selectedPiece = null;
                    }
                    setTimeout(() => e.target.classList.add('dragging'), 0); // Add dragging class after a delay
                });

                gameContainer.addEventListener('dragend', (e) => {
                    // Clean up after dragging ends.
                    if(draggedPiece) {
                        draggedPiece.classList.remove('dragging');
                        draggedPiece = null;
                    }
                });

                // Prevent the default behavior to allow a drop.
                gameContainer.addEventListener('dragover', (e) => {
                    e.preventDefault(); 
                });

                gameContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedPiece) {
                        const subSquareTarget = e.target.closest('.sub-square');
                        const baseSquareTarget = e.target.closest('.base-square');

                        // If dropped on a game board square, attempt a move.
                        if (subSquareTarget) {
                            const mainId = parseInt(subSquareTarget.dataset.mainSquare);
                            const subId = parseInt(subSquareTarget.dataset.subSquare);
                            movePiece(draggedPiece, mainId, subId);
                        // If dropped on a base square, attempt to return to base.
                        } else if (baseSquareTarget) {
                            const base = baseSquareTarget.closest('.base');
                            if (base) {
                                const baseOwnerId = parseInt(base.id.replace('player', '').replace('-base', ''));
                                if (baseOwnerId === currentPlayer) { // Can only return to your own base
                                    movePiece(draggedPiece, -1, -1); // Use -1 as a flag for returning to base
                                }
                            }
                        }
                        // Clean up after drop.
                        draggedPiece.classList.remove('dragging');
                        draggedPiece = null;
                    }
                });
            }
            
            // Sets the current action ('move' or 'rotate') and updates the UI buttons.
            function setAction(action) {
                currentAction = action;
                movePieceBtn.classList.toggle('active', action === 'move');
                rotateSquareBtn.classList.toggle('active', action === 'rotate');
                // Deselect any piece if switching to rotate mode.
                if (action === 'rotate' && selectedPiece) {
                    selectedPiece.classList.remove('selected');
                    selectedPiece = null;
                }
            }

            // Handles all click events within the game container.
            function handleGameClick(e) {
                const target = e.target;
                // If in 'rotate' mode, try to rotate the clicked main square.
                if (currentAction === 'rotate') {
                    const mainSquare = target.closest('.main-square');
                    if (mainSquare) {
                        rotateMainSquare(mainSquare);
                    }
                    return;
                }
                
                // --- Click-to-Move Logic ---
                if (currentAction === 'move') {
                    const clickedPiece = target.closest('.piece');
                    // If a piece belonging to the current player is clicked...
                    if (clickedPiece && parseInt(clickedPiece.dataset.player) === currentPlayer) {
                        if (selectedPiece) {
                            selectedPiece.classList.remove('selected');
                        }
                        // Deselect if clicking the same piece again.
                        if (selectedPiece === clickedPiece) {
                            selectedPiece = null; 
                        } else {
                            // Otherwise, select the new piece.
                            selectedPiece = clickedPiece;
                            selectedPiece.classList.add('selected');
                        }
                    // If a piece is already selected and a square is clicked...
                    } else if (selectedPiece) {
                        const subSquareTarget = target.closest('.sub-square');
                        const baseSquareTarget = target.closest('.base-square');

                        // If a board square is clicked, try to move there.
                        if (subSquareTarget) {
                            const mainId = parseInt(subSquareTarget.dataset.mainSquare);
                            const subId = parseInt(subSquareTarget.dataset.subSquare);
                            movePiece(selectedPiece, mainId, subId);
                        // If a base square is clicked, try to return to base.
                        } else if (baseSquareTarget) {
                             const base = baseSquareTarget.closest('.base');
                             if (base && parseInt(base.id.replace('player', '').replace('-base', '')) === currentPlayer) {
                                movePiece(selectedPiece, -1, -1);
                             }
                        }
                    }
                }
            }
            
            // --- Core Game Mechanics ---

            // Checks if a player has lost all their pieces.
            function checkForElimination(playerId) {
                if (!activePlayers.includes(playerId)) return; // Don't check already eliminated players

                const graveyard = document.getElementById(`player${playerId}-graveyard`);
                if (graveyard && graveyard.children.length >= 3) {
                    // Remove player from the active list.
                    const playerIndex = activePlayers.indexOf(playerId);
                    if (playerIndex > -1) {
                        activePlayers.splice(playerIndex, 1);
                    }
                    showMessage(`Player ${playerId} has been eliminated!`);

                    // Check for a winner.
                    if (activePlayers.length === 1) {
                        showGameOverScreen(`Player ${activePlayers[0]} is the winner!`);
                    } else if (activePlayers.length < 1) { // Should not happen, but for safety
                        showGameOverScreen("It's a draw!");
                    }
                }
            }

            // The main function that handles moving a piece element to a new square.
            function movePiece(pieceElement, mainSquareId, subSquareId) {
                if (isGameOver) return;
                const pieceData = getPieceObject(pieceElement);
                if (!pieceData) return;

                // Validate the move before proceeding.
                const moveValidation = isValidMove(pieceData, mainSquareId, subSquareId);
                if (!moveValidation.valid) {
                    showMessage(moveValidation.reason);
                    return;
                }
                
                // --- Execute the Move ---
                // If moving back to base...
                if (mainSquareId === -1) {
                    const base = document.getElementById(`player${pieceData.player}-base`);
                    // Find an empty square in the base.
                    const emptyBaseSquare = Array.from(base.children).find(child => child.classList.contains('base-square') && !child.firstChild);
                    if (emptyBaseSquare) {
                        emptyBaseSquare.appendChild(pieceElement);
                    } else {
                        showMessage("Your base is full!");
                        return;
                    }
                // If moving to a board square...
                } else {
                    const targetSquare = document.querySelector(`[data-main-square='${mainSquareId}'][data-sub-square='${subSquareId}']`);
                    // If the target square is occupied...
                    if (targetSquare.firstChild) {
                        const targetPiece = targetSquare.firstChild;
                        const targetPieceData = getPieceObject(targetPiece);
                        // Check if the moving piece can "eat" the target piece.
                        if(canEat(pieceData, targetPieceData)) {
                            const graveyard = document.getElementById(`player${targetPieceData.player}-graveyard`);
                            if (graveyard) {
                                targetPiece.draggable = false;
                                graveyard.appendChild(targetPiece); // Move target to its graveyard
                                checkForElimination(targetPieceData.player); // Check if this capture eliminated the player
                            }
                        } else {
                            showMessage("Cannot eat that piece!");
                            return;
                        }
                    }
                    targetSquare.appendChild(pieceElement); // Move the piece to the target square
                }
                
                // Deselect the piece after a successful move.
                if (selectedPiece) {
                    selectedPiece.classList.remove('selected');
                    selectedPiece = null;
                }

                // --- Update Game State Post-Move ---
                pieceData.movesThisTurn++;
                pieceElement.querySelector('.move-counter').textContent = pieceData.movesThisTurn;
                movesLeft--;
                updateMovesDisplay();

                // Logic for the "one piece twice or two pieces once" rule.
                if(pieceMovedTwice && pieceElement !== pieceMovedTwice.element) {
                    // If a different piece was moved second, the turn ends.
                    movesLeft = 0;
                } else if(pieceMovedTwice && pieceElement === pieceMovedTwice.element) {
                    // If the same piece was moved a second time, the turn ends.
                    movesLeft = 0;
                } else if (movesLeft === 1) {
                    // If this is the first move of the turn, track which piece was moved.
                    pieceMovedTwice = { element: pieceElement };
                } 
                
                // If no moves are left, proceed to the next turn.
                if(movesLeft <= 0) nextTurn();
            }

            // Helper function to get the main square ID for a player's home corner.
            function getHomeMainSquareId(player) {
                switch(player) {
                    case 1: return 0; // Top-left
                    case 2: return 2; // Top-right
                    case 3: return 6; // Bottom-left
                    case 4: return 8; // Bottom-right
                    default: return null;
                }
            }
            
            // Checks if the path between two coordinates is blocked by a wall or another piece.
            function isPathClear(curTotalRow, curTotalCol, targetTotalRow, targetTotalCol) {
                const rowDiff = targetTotalRow - curTotalRow;
                const colDiff = targetTotalCol - curTotalCol;
                // Determine the direction of movement (1, -1, or 0).
                const rowStep = Math.sign(rowDiff);
                const colStep = Math.sign(colDiff);

                let currentRow = curTotalRow + rowStep;
                let currentCol = curTotalCol + colStep;

                // Iterate through each square along the path.
                while (currentRow !== targetTotalRow || currentCol !== targetTotalCol) {
                    // Convert the absolute row/col back to main/sub square IDs.
                    const mainRow = Math.floor(currentRow / 3);
                    const mainCol = Math.floor(currentCol / 3);
                    const subRow = currentRow % 3;
                    const subCol = currentCol % 3;
                    const mainId = mainRow * 3 + mainCol;
                    const subId = subRow * 3 + subCol;
                    
                    const intermediateSquare = document.querySelector(`[data-main-square='${mainId}'][data-sub-square='${subId}']`);
                    if (intermediateSquare && (intermediateSquare.firstChild || intermediateSquare.classList.contains('wall'))) {
                        return false; // Path is blocked
                    }

                    currentRow += rowStep;
                    currentCol += colStep;
                }

                return true; // Path is clear
            }

            // Comprehensive move validation function.
            function isValidMove(piece, mainId, subId) {
                 const currentPos = findPiecePosition(piece.element);
                 const targetSquare = document.querySelector(`[data-main-square='${mainId}'][data-sub-square='${subId}']`);

                 // --- Case 1: Moving from base onto the board ---
                 if (!currentPos.onBoard && !currentPos.inGraveyard) {
                     const homeMainSquareId = getHomeMainSquareId(piece.player);
                     // Can only enter the board on your designated home main square.
                     if (mainId !== homeMainSquareId) return { valid: false, reason: "Can only enter on your home square." };
                     if(targetSquare.classList.contains('wall')) return { valid: false, reason: "Cannot move onto a wall." };
                     return { valid: true };
                 } 
                 
                 // --- Case 2: Moving on the board or back to base ---
                 if (currentPos.onBoard) {
                    // Moving back to base
                    if (mainId === -1) {
                        const homeMainSquareId = getHomeMainSquareId(piece.player);
                        // Can only return to base from your home main square.
                        if (currentPos.main !== homeMainSquareId) return { valid: false, reason: "Can only return to base from your home square."};
                        return { valid: true };
                    } 
                    
                    if(targetSquare.classList.contains('wall')) return { valid: false, reason: "Cannot move onto a wall." };

                    // Convert main/sub IDs to an absolute 9x9 grid coordinate system for easier path calculation.
                    const {mainRow: curMainRow, mainCol: curMainCol, subRow: curSubRow, subCol: curSubCol} = getCoordsFromIds(currentPos.main, currentPos.sub);
                    const {mainRow: targetMainRow, mainCol: targetMainCol, subRow: targetSubRow, subCol: targetSubCol} = getCoordsFromIds(mainId, subId);

                    const curTotalRow = curMainRow * 3 + curSubRow;
                    const curTotalCol = curMainCol * 3 + curSubCol;
                    const targetTotalRow = targetMainRow * 3 + targetSubRow;
                    const targetTotalCol = targetMainCol * 3 + targetSubCol;
                    
                    if (curTotalRow === targetTotalRow && curTotalCol === targetTotalCol) return { valid: false, reason: "Must move to a different square." };

                    // Calculate row/column difference to check move type.
                    const totalRowDiff = Math.abs(targetTotalRow - curTotalRow);
                    const totalColDiff = Math.abs(targetTotalCol - curTotalCol);

                    // Check if the move matches the piece's allowed movement type using internal names.
                    let moveTypeValid = false;
                    if(piece.type === "plus-piece") moveTypeValid = (totalRowDiff > 0 && totalColDiff === 0) || (totalRowDiff === 0 && totalColDiff > 0); // Rook
                    if(piece.type === "x-piece") moveTypeValid = totalRowDiff > 0 && totalRowDiff === totalColDiff; // Bishop
                    if(piece.type === "star-piece") moveTypeValid = (totalRowDiff > 0 && totalColDiff === 0) || (totalRowDiff === 0 && totalColDiff > 0) || (totalRowDiff > 0 && totalRowDiff === totalColDiff); // Queen
                    
                    if (!moveTypeValid) return { valid: false, reason: "This piece cannot move like that." };
                    if (!isPathClear(curTotalRow, curTotalCol, targetTotalRow, targetTotalCol)) return { valid: false, reason: "Path is blocked by a piece or wall." };

                    return { valid: true };
                 }
                 
                 return { valid: false, reason: "Piece is not in a valid location." }; // Fallback
            }

            // Checks the "rock-paper-scissors" capture logic using internal names.
            function canEat(attacker, defender) {
                if (!attacker || !defender) return false;
                if (attacker.player === defender.player) return false; // Cannot eat your own piece
                if(attacker.type === 'plus-piece' && defender.type === 'x-piece') return true;
                if(attacker.type === 'x-piece' && defender.type === 'star-piece') return true;
                if(attacker.type === 'star-piece' && defender.type === 'plus-piece') return true;
                return false;
            }
            
            // Rotates the sub-squares within a main square 90 degrees clockwise.
            function rotateMainSquare(mainSquareElement) {
                if (isGameOver) return;
                const subSquares = Array.from(mainSquareElement.children);
                // Define the new order of sub-squares after a clockwise rotation.
                const newOrder = [
                    subSquares[6], subSquares[3], subSquares[0],
                    subSquares[7], subSquares[4], subSquares[1],
                    subSquares[8], subSquares[5], subSquares[2]
                ];
                
                mainSquareElement.innerHTML = ''; // Clear the main square
                // Append the sub-squares in their new order and update their dataset index.
                newOrder.forEach((square, index) => {
                    square.dataset.subSquare = index; 
                    mainSquareElement.appendChild(square);
                });
                
                // A rotation counts as one move.
                movesLeft--;
                updateMovesDisplay();
                if(movesLeft <= 0) nextTurn();
            }
            
            // --- Helper Functions ---

            // Retrieves the data object for a piece from the 'players' object using its DOM element.
            function getPieceObject(pieceElement) {
                if (!pieceElement) return null;
                const player = parseInt(pieceElement.dataset.player);
                if (players[player]) {
                    return players[player].find(p => p.element === pieceElement);
                }
                return null;
            }
            
            // Finds the location of a piece element (on board, in base, or in graveyard).
            function findPiecePosition(pieceElement) {
                const parent = pieceElement.parentElement;
                if (parent.classList.contains('sub-square')) {
                    return { onBoard: true, main: parseInt(parent.dataset.mainSquare), sub: parseInt(parent.dataset.subSquare) };
                } else if (parent.classList.contains('base-square')) { 
                     const base = parent.closest('.base');
                     return { onBoard: false, inGraveyard: false, base: parseInt(base.id.replace('player','').replace('-base','')) };
                }
                return { onBoard: false, inGraveyard: true }; // Assumed to be in graveyard if not elsewhere
            }
            
            // Converts main and sub square IDs into row/column coordinates.
            function getCoordsFromIds(mainId, subId){
                return { mainRow: Math.floor(mainId / 3), mainCol: mainId % 3, subRow: Math.floor(subId / 3), subCol: subId % 3 };
            }
            
            // --- UI Update Functions ---
            
            function updateTurnDisplay() {
                turnDisplay.textContent = `Turn: Player ${currentPlayer}`;
                turnDisplay.style.color = playerColors[currentPlayer];
            }

            function updateMovesDisplay() {
                movesCounterDisplay.textContent = `Moves Made: ${2 - movesLeft} / 2`;
            }

            // --- Turn Management ---

            // Advances the game to the next player's turn.
            function nextTurn() {
            if (isGameOver) return;
            if (movesLeft > 0 || activePlayers.length <= 1) return;

            // Deselect any selected piece.
            if (selectedPiece) {
                selectedPiece.classList.remove('selected');
                selectedPiece = null;
            }

            // Find the next active player in the rotation.
            const currentPlayerIndex = activePlayers.indexOf(currentPlayer);
            const nextPlayerIndex = (currentPlayerIndex + 1) % activePlayers.length;
            currentPlayer = activePlayers[nextPlayerIndex];

            // Reset the move counter for the new current player's pieces.
                if (players[currentPlayer]) {
                    players[currentPlayer].forEach(p => {
                        p.movesThisTurn = 0;
                        // This condition correctly checks if the piece is NOT in a graveyard before updating the text.
                        if (p.element.parentElement && !p.element.parentElement.closest('.graveyard')) {
                            p.element.querySelector('.move-counter').textContent = '0';
                        }
                    });
                }
                
                // Increment the overall turn counter after a full round of players.
                if (currentPlayerIndex === activePlayers.length - 1 || activePlayers.length === numPlayers) {
                     turnCount++;
                }
                
                // Reset turn state.
                movesLeft = 2;
                pieceMovedTwice = null;
                
                // Update UI and check for stalemate.
                updateTurnDisplay();
                updateMovesDisplay();
                turnCounterDisplay.textContent = `Turn #: ${turnCount}`;
                setAction('move'); // Default action is 'move'
                checkStalemate();

                // If it's a bot game and now the bot's turn, trigger its logic.
                if (isBotGame && currentPlayer === 2) {
                    playBotTurn();
                }
            }

                // Checks for a stalemate condition where no more captures are possible.
                function checkStalemate() {
                    if (activePlayers.length <= 1) return;
                    const activePieces = [];
                    // Get a list of all pieces not in a graveyard.
                    activePlayers.forEach(p => {
                        players[p].forEach(pieceData => {
                            if (!findPiecePosition(pieceData.element).inGraveyard) {
                                activePieces.push(pieceData);
                            }
                        });
                    });

                    // Check if any piece can eat any other piece.
                    let possibleCapture = false;
                    for (let i = 0; i < activePieces.length; i++) {
                        for (let j = 0; j < activePieces.length; j++) {
                            if (i === j) continue;
                            if (canEat(activePieces[i], activePieces[j])) {
                                possibleCapture = true;
                                break;
                            }
                        }
                        if (possibleCapture) break;
                    }

                // If no captures are possible, the game ends in a stalemate.
                if (!possibleCapture) {
                    // --- Stalemate Tie-Breaker Logic ---
                    let playerPieceCount = {};
                    let playerHighestValue = {};
                    
                    activePlayers.forEach(p => {
                        playerPieceCount[p] = 0;
                        playerHighestValue[p] = 0;
                    });
                    
                    // Count pieces and find the highest value piece for each player.
                    activePieces.forEach(p => {
                       playerPieceCount[p.player]++;
                       if(pieceValues[p.type] > playerHighestValue[p.player]){
                           playerHighestValue[p.player] = pieceValues[p.type];
                       }
                    });

                    // Tie-breaker 1: Player with the most pieces wins.
                    let maxPieces = -1;
                    let playersWithMaxPieces = [];
                    activePlayers.forEach(p => {
                         if(playerPieceCount[p] > maxPieces){
                            maxPieces = playerPieceCount[p];
                            playersWithMaxPieces = [p];
                         } else if (playerPieceCount[p] === maxPieces) {
                            playersWithMaxPieces.push(p);
                         }
                    });

                    if(playersWithMaxPieces.length === 1) {
                         showGameOverScreen(`Stalemate! Player ${playersWithMaxPieces[0]} wins with the most pieces!`);
                         return;
                    }

                    // Tie-breaker 2: If still tied, player with the highest value piece wins.
                    let maxValue = -1;
                    let winningPlayers = [];
                     playersWithMaxPieces.forEach(p => {
                        if(playerHighestValue[p] > maxValue) {
                            maxValue = playerHighestValue[p];
                            winningPlayers = [p];
                        } else if (playerHighestValue[p] === maxValue) {
                            winningPlayers.push(p);
                        }
                    });

                    if(winningPlayers.length === 1) {
                        showGameOverScreen(`Stalemate! Player ${winningPlayers[0]} wins with the highest value piece!`);
                    } else {
                        // If still tied, it's a draw.
                        showGameOverScreen("Stalemate! No more captures possible. It's a draw!");
                    }
                }
            }

            // --- Bot (AI) Logic ---

            // Helper: Try to move a piece from the base onto the board.
            function botAttemptMoveFromBase() {
                const botPiecesInBase = players[2].filter(p => {
                    const pos = findPiecePosition(p.element);
                    return !pos.onBoard && !pos.inGraveyard;
                });
                if (botPiecesInBase.length > 0) {
                    const pieceToMove = botPiecesInBase[0];
                    const homeMainSquareId = getHomeMainSquareId(2);
                    const homeMainSquare = document.querySelector(`[data-main-square-id='${homeMainSquareId}']`);
                    const targetSubSquares = Array.from(homeMainSquare.children);
                    const validTargets = targetSubSquares.filter(square => !square.classList.contains('wall') && (!square.firstChild || canEat(pieceToMove, getPieceObject(square.firstChild))));

                    if (validTargets.length > 0) {
                        const targetSquare = validTargets[Math.floor(Math.random() * validTargets.length)];
                        movePiece(pieceToMove.element, parseInt(targetSquare.dataset.mainSquare), parseInt(targetSquare.dataset.subSquare));
                        return true;
                    }
                }
                return false;
            }

            // Helper: Try to move a piece on the board to a random empty square.
            function botAttemptMoveOnBoard() {
                const botPiecesOnBoard = players[2].filter(p => findPiecePosition(p.element).onBoard);
                if (botPiecesOnBoard.length > 0) {
                    const shuffledPieces = botPiecesOnBoard.sort(() => 0.5 - Math.random());
                    const allSubSquares = Array.from(document.querySelectorAll('.sub-square'));

                    for (const piece of shuffledPieces) {
                        const emptyValidMoves = allSubSquares.filter(sq => !sq.firstChild && isValidMove(piece, parseInt(sq.dataset.mainSquare), parseInt(sq.dataset.subSquare)).valid);
                        if (emptyValidMoves.length > 0) {
                            const targetSquare = emptyValidMoves[Math.floor(Math.random() * emptyValidMoves.length)];
                            movePiece(piece.element, parseInt(targetSquare.dataset.mainSquare), parseInt(targetSquare.dataset.subSquare));
                            return true;
                        }
                    }
                }
                return false;
            }

            // EASY: Move from base, then move randomly on board.
            function playEasyBotTurn() {
                if (botAttemptMoveFromBase()) return true;
                if (botAttemptMoveOnBoard()) return true;
                return false;
            }

            // MEDIUM: Look for any capture, otherwise play like Easy.
            function playMediumBotTurn() {
                const botPiecesOnBoard = players[2].filter(p => findPiecePosition(p.element).onBoard);
                const opponentPieces = players[1].filter(p => findPiecePosition(p.element).onBoard);

                // Priority 1: Find any possible capture.
                for (const botPiece of botPiecesOnBoard) {
                    for (const opponentPiece of opponentPieces) {
                        const opponentPos = findPiecePosition(opponentPiece.element);
                        if (canEat(botPiece, opponentPiece) && isValidMove(botPiece, opponentPos.main, opponentPos.sub).valid) {
                            movePiece(botPiece.element, opponentPos.main, opponentPos.sub);
                            return true;
                        }
                    }
                }

                // Priority 2 & 3: Play like Easy.
                if (botAttemptMoveFromBase()) return true;
                if (botAttemptMoveOnBoard()) return true;
                return false;
            }
            
            // HARD: Look for best capture, then escape threats, then play like Easy.
            function playHardBotTurn() {
                const botPiecesOnBoard = players[2].filter(p => findPiecePosition(p.element).onBoard);
                const opponentPieces = players[1].filter(p => findPiecePosition(p.element).onBoard);

                // Priority 1: Find the BEST possible capture.
                let possibleCaptures = [];
                for (const botPiece of botPiecesOnBoard) {
                    for (const opponentPiece of opponentPieces) {
                        const opponentPos = findPiecePosition(opponentPiece.element);
                        if (canEat(botPiece, opponentPiece) && isValidMove(botPiece, opponentPos.main, opponentPos.sub).valid) {
                            possibleCaptures.push({
                                attacker: botPiece.element,
                                targetPos: opponentPos,
                                value: pieceValues[opponentPiece.type] || 0
                            });
                        }
                    }
                }

                if (possibleCaptures.length > 0) {
                    possibleCaptures.sort((a, b) => b.value - a.value); // Sort by highest value
                    const bestCapture = possibleCaptures[0];
                    movePiece(bestCapture.attacker, bestCapture.targetPos.main, bestCapture.targetPos.sub);
                    return true;
                }

                // Priority 2: Escape a threat.
                for (const botPiece of botPiecesOnBoard) {
                    const botPos = findPiecePosition(botPiece.element);
                    let isThreatened = false;
                    for (const opponentPiece of opponentPieces) {
                        if (canEat(opponentPiece, botPiece) && isValidMove(opponentPiece, botPos.main, botPos.sub).valid) {
                            isThreatened = true;
                            break;
                        }
                    }
                    if (isThreatened) {
                        const allSubSquares = Array.from(document.querySelectorAll('.sub-square'));
                        const validMoves = allSubSquares.filter(sq => !sq.firstChild && isValidMove(botPiece, parseInt(sq.dataset.mainSquare), parseInt(sq.dataset.subSquare)).valid);
                        if (validMoves.length > 0) {
                            const targetSquare = validMoves[Math.floor(Math.random() * validMoves.length)];
                            movePiece(botPiece.element, parseInt(targetSquare.dataset.mainSquare), parseInt(targetSquare.dataset.subSquare));
                            return true;
                        }
                    }
                }

                // Priority 3 & 4: Play like Easy.
                if (botAttemptMoveFromBase()) return true;
                if (botAttemptMoveOnBoard()) return true;
                return false;
            }


            // This function contains the logic for the computer player's turn.
            function playBotTurn() {
                // The main action-taking function for the bot.
                const doBotAction = () => {
                    if (movesLeft <= 0 || !activePlayers.includes(2) || isGameOver) return;

                    let actionTaken = false;
                    // Route to the correct difficulty logic.
                    if (botDifficulty === 'easy') {
                        actionTaken = playEasyBotTurn();
                    } else if (botDifficulty === 'medium') {
                        actionTaken = playMediumBotTurn();
                    } else if (botDifficulty === 'hard') {
                        actionTaken = playHardBotTurn();
                    }
                    
                    // Fallback: If no other action was taken, rotate a random square.
                    if (!actionTaken) {
                        const allMainSquares = Array.from(document.querySelectorAll('.main-square'));
                        const randomMainSquare = allMainSquares[Math.floor(Math.random() * allMainSquares.length)];
                        rotateMainSquare(randomMainSquare);
                    }
                };

                // Use timeouts to create a delay, making the bot's moves feel more natural.
                setTimeout(() => {
                    doBotAction(); // Perform the first action.
                    if (movesLeft > 0) {
                        setTimeout(() => {
                           doBotAction(); // Perform the second action if the turn isn't over.
                        }, 800);
                    }
                }, 800);
            }
        });
    </script>

</body>
</html>

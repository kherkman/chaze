<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chaze</title>
    <style>
        /* --- Basic Page Setup --- */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #000; /* Black background */
            color: white; /* White text */
            display: flex; /* Use flexbox for centering */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            height: 100vh; /* Full viewport height */
            overflow: hidden; /* Hide scrollbars */
        }

        /* --- Scalable Container for Resolution Independence --- */
        /* This container holds the entire game and is scaled with JavaScript to fit the user's screen. */
        #scalable-content {
            width: 1280px; /* Native resolution width */
            height: 900px; /* Native resolution height */
            position: relative;
            transform-origin: center center; /* Scale from the center */
        }

        /* --- Start, Game Over, and Instructions Screens --- */
        /* These screens overlay the game area. */
        #startScreen, #gameOverScreen, #instructionsScreen {
            text-align: center;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex; /* Use flexbox for content alignment */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100; /* Ensure they appear on top of the game */
        }
        
        #startScreen, #instructionsScreen {
            background-color: rgba(0, 0, 0, 0.85); /* Opaque background for start and instructions */
        }

        #gameOverScreen {
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background for game over */
        }


        /* For the CHAZE title */
        #startScreen h1 {
            font-size: 150px;  /* Changed between 10vw and 150px  */
            margin-bottom: 1px;
        }

        /* For the Game Over title (keeping it larger) */
        #gameOverScreen h1 {
            font-size: 150px; /* Changed between 10vw and 150px  */
            margin-bottom: 20px;
        }

        /* Add a strong shadow to all text on the game over screen for readability */
        #gameOverScreen h1, #gameOverScreen p, #gameOverScreen span {
            text-shadow: 3px 3px 8px #000, -3px -3px 8px #000;
        }

        #startScreen p {
            font-size: 24px; /* Changed between 2vw and 24px  */
        }
        
        /* --- Styles for Dropdown Alignment --- */
        .selection-container {
            display: flex; /* Aligns children (the divs) in a row */
            flex-wrap: wrap; /* Allows items to wrap to the next line if they don't fit */
            justify-content: center; /* Centers the items horizontally */
            align-items: flex-start; /* Aligns items to the top */
            gap: 10px; /* Adds space between the dropdown sections */
            margin-bottom: 10px; /* Adds some space before the start button */
        }

        .player-selection, .difficulty-selection, .time-selection, .gametype-selection {
            display: flex; /* Ensures label and select box align well */
            flex-direction: column; /* Stacks the label on top of the select box */
            text-align: center;
        }

        #gameOverScreen p {
            font-size: 40px; /* Changed from vw to px for proper scaling */
            line-height: 1.5;
            color: #ffc107; /* Amber color for the winner info */
            margin-bottom: 30px;
        }

        #gameOverScreen span {
            font-size: 28px; /* Changed from vw to px for proper scaling */
            color: #ccc; /* Light grey for helper text */
        }

        #playerCount, #botDifficulty, #turnTime, #gameType {
            font-size: 1.5em;
            margin: 10px;
            padding: 10px;
        }

        /* --- Button Container on Start Screen --- */
        .button-container {
            display: flex;
            gap: 20px; /* Adds space between buttons */
            align-items: center; /* Aligns buttons vertically */
        }

        #instructionsButton, #startButton, #closeInstructionsButton {
             font-size: 1.5em;
             margin: 10px;
             padding: 10px 20px;
             cursor: pointer;
        }
        
        /* --- Start Button Enhancement --- */
        #startButton {
            background-color: #28a745; /* A strong green */
            color: white;
            border: none;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            font-weight: bold;
            transition: transform 0.2s ease, background-color 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #startButton:hover {
            background-color: #218838; /* A slightly darker green on hover */
            transform: scale(1.05); /* Make it slightly larger on hover */
        }

        /* --- Instructions Screen Styling --- */
        #instructions-content {
            background-color: #222;
            padding: 40px 60px;
            border-radius: 15px;
            border: 2px solid #888;
            max-width: 800px;
            text-align: left;
        }

        #instructions-content h1 {
            font-size: 50px;
            margin-top: 0;
            color: #ffc107;
            text-align: center;
        }

        #instructions-content p {
            font-size: 20px;
            line-height: 1.6;
        }

        /* --- Main Game Container --- */
        #gameContainer {
            display: none; /* Initially hidden until the game starts */
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        
        /* --- Top Information Area (Turn, Controls, Rules) --- */
        #info-area {
            width: 800px;
            text-align: center;
            margin-top: 20px;
        }

        /* Container for turn display and action buttons */
        #gameInfo {
            display: flex;
            justify-content: space-between; /* Space out the items */
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
            font-size: 1.2em;
        }
        
        /* Buttons for switching between moving and rotating */
        #action-controls button {
            font-size: 1em;
            padding: 10px 15px;
            margin: 0 5px;
            border: 2px solid #aaa;
            background-color: #555;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
        }
        
        /* Style for the currently active button */
        #action-controls button.active {
            background-color: #ddd;
            color: #333;
            border-color: #fff;
        }

        /* Displays whose turn it is */
        #turn-display {
            font-weight: bold;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px #000;
        }

        /* Displays the turn timer countdown */
        #timer-display {
            font-size: 1.8em;
            font-weight: bold;
            color: #ffc107; /* Amber */
        }
        
        /* Displays moves left in the current turn */
        #moves-counter {
            font-size: 1.1em;
            color: #ccc;
            margin-top: 5px;
        }

        /* Display for Last Stand warning */
        #last-stand-display {
            margin-top: 8px;
            font-size: 1.8em;
            font-weight: bold;
            color: #ff4d4d;
            height: 30px; /* Reserve space to prevent layout shift */
            animation: glow 1.5s infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 5px #ff0000, 0 0 10px #ff0000;
            }
            to {
                text-shadow: 0 0 15px #ff4d4d, 0 0 20px #ff4d4d;
            }
        }
        
        /* Displays the "rock-paper-scissors" eating rules */
        #rules-display {
            margin-top: 10px;
            margin-bottom: 20px;
            padding: 5px;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.2);
            font-size: 1.1em;
            color: #ddd;
            text-align: center;
        }

        #rules-display span {
            font-weight: bold;
            font-size: 1.5em;
            vertical-align: middle;
            display: inline-block;
            margin: 0 5px;
        }

        /* --- Board and Pieces Area --- */
        #board-container {
            position: relative; /* Needed for absolute positioning of bases and graveyards */
            width: 614px;
            height: 614px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Player's starting area (home base) */
        .base {
            position: absolute; /* Positioned outside the main board */
            width: 150px; 
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            z-index: 10;
            pointer-events: none; /* Allows clicks to pass through the container itself */
        }

        /* Positioning for each player's base in the corners */
        #player1-base { top: -100px; left: -100px; }
        #player2-base { top: -100px; right: -100px; }
        #player3-base { bottom: -100px; left: -100px; }
        #player4-base { bottom: -100px; right: -100px; }

        .base-square {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            pointer-events: auto; /* Makes the individual squares clickable again */
        }

        /* Ensures pieces in the base are the same size as on the board. */
        .base-square .piece {
            font-size: 1.8em;
        }

        /* Colors for each player's base */
        #player1-base .base-square { background-color: cyan; }
        #player2-base .base-square { background-color: yellow; }
        #player3-base .base-square { background-color: magenta; }
        #player4-base .base-square { background-color: green; }
        
        /* Area where captured pieces go */
        .graveyard {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
            width: 60px;
            height: 200px;
            border: 2px dashed #777;
            border-radius: 5px;
            z-index: 20;
        }
        
        /* Positioning for each player's graveyard */
        #player1-graveyard { top: -100px; left: -200px; }
        #player2-graveyard { top: -100px; right: -200px; }
        #player3-graveyard { bottom: -100px; left: -200px; }
        #player4-graveyard { bottom: -100px; right: -200px; }


        .graveyard .piece {
            width: 45px;
            height: 45px;
            font-size: 1.8em; /* Makes graveyard pieces same size as on the board. */
            cursor: not-allowed; /* Indicates these pieces cannot be moved */
            opacity: 0.6; /* Faded appearance for captured pieces */
        }
        /* Hide the move counter on captured pieces */
        .graveyard .piece .move-counter { display: none; }
        
        /* Style for the last stand timer in the graveyard */
        .last-stand-timer {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: #ff0000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            font-weight: bold;
            box-shadow: 0 0 10px #ff0000, 0 0 15px #ff4d4d;
        }

        /* Style for the eats counter */
        .eats-counter {
            position: absolute;
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px #000;
            z-index: 25;
        }
        
        #player1-eats-counter { top: 60px; left: -100px; }
        #player2-eats-counter { top: 60px; right: -100px; }
        #player3-eats-counter { bottom: 60px; left: -100px; }
        #player4-eats-counter { bottom: 60px; right: -100px; }


        /* The main 3x3 grid of major squares */
        #game-board {
            display: grid;
            width: 600px;
            height: 600px;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            background-color: #666;
            padding: 5px;
            border: 2px solid #999;
        }

        /* Each of the 9 large squares, which can be rotated */
        .main-square {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            background-color: white;
        }

        /* Each of the 81 small squares where pieces can be placed */
        .sub-square {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em; /* This determines the size of the piece symbol on the board */
            font-weight: bold;
            cursor: pointer;
        }
        
        /* Impassable squares */
        .wall {
            background-color: #5a5a5a;
            cursor: not-allowed;
        }
        
        /* --- General Piece Styling --- */
        .piece {
            position: relative; /* For positioning the move counter */
            border-radius: 50%; /* Makes the piece circular */
            width: 80%;
            height: 80%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: black;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4); /* Adds depth */
            cursor: grab; /* Indicates the piece can be dragged */
            box-sizing: border-box; /* Ensures border is included in width/height calculation */
        }
        
        /* Style for a piece being dragged */
        .piece.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        /* Style for a piece that is selected for a click-to-move action */
        .piece.selected {
            border: 4px solid white; /* White outline when selected */
        }

        /* Small number on the piece showing moves this turn */
        .move-counter {
            position: absolute;
            bottom: 1px;
            right: 4px;
            font-size: 0.5em; /* Relative to the piece's font-size */
            font-weight: bold;
            background: rgba(255, 255, 255, 0.7);
            color: black;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Message Overlay --- */
        /* Used for temporary messages like "Path is blocked". */
        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 200;
            pointer-events: none; /* Let clicks pass through to the game */
        }

        #message-overlay p {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 2.5em;
            color: white;
            text-shadow: 2px 2px 5px #000;
            white-space: pre-wrap; /* Allows \n to create new lines */
            text-align: center;
        }

        /* --- Player-Specific Colors --- */
        .player1 { background-color: cyan; }
        .player2 { background-color: yellow; }
        .player3 { background-color: magenta; }
        .player4 { background-color: green; }

    </style>
</head>
<body>
    <div id="scalable-content">
        <!-- The initial screen with game title and player selection -->
        <div id="startScreen">
            <h1>CHAZE</h1>
                <div class="selection-container">
                     <div class="gametype-selection">
                        <label for="gameType">Game Type:</label>
                        <select id="gameType">
                            <option value="single">Single Game</option>
                            <option value="tournament">3 Game Tournament</option>
                        </select>
                    </div>
                    <div class="player-selection">
                        <label for="playerCount">Select Game Mode:</label>
                        <select id="playerCount">
                            <option value="1">1 Player vs Bot</option>
                            <option value="2">2 Players</option>
                            <option value="3">3 Players</option>
                            <option value="4">4 Players</option>
                            <option value="2-bots">1 Player vs 2 Bots</option>
                            <option value="3-bots">1 Player vs 3 Bots</option>
                            <option value="2v2">2 Players vs 2 Bots</option>
                        </select>
                    </div>
                    <div class="difficulty-selection">
                        <label for="botDifficulty">Bot Difficulty:</label>
                        <select id="botDifficulty">
                            <option value="easy">Easy</option>
                            <option value="medium">Medium</option>
                            <option value="hard">Hard</option>
                        </select>
                    </div>
                    <div class="time-selection">
                        <label for="turnTime">Turn Time:</label>
                        <select id="turnTime">
                            <option value="Infinite">Infinite</option>
                            <option value="5">5 seconds</option>
                            <option value="10">10 seconds</option>
                            <option value="15">15 seconds</option>
                        </select>
                    </div>
                </div>
                <div class="button-container">
                    <button id="instructionsButton">Instructions</button>
                    <button id="startButton">Start Game</button>
                </div>

            <p>
            The "<span id="p-plus"></span>" moves horizontally or vertically.<br>
            The "<span id="p-star"></span>" moves horizontally, vertically, or diagonally.<br>
            The "<span id="p-x"></span>" moves diagonally.
            </p>

            </div>

         <!-- The screen shown when the game ends -->
         <div id="gameOverScreen" style="display: none;">
            <h1 id="gameOverTitle">Game Over</h1>
            <p id="winner-info"></p>
            <span id="gameOverPrompt">Click anywhere to Play Again</span>
        </div>

        <!-- The instructions screen -->
        <div id="instructionsScreen" style="display: none;">
            <div id="instructions-content">
                <h1>Instructions</h1>
                <p>
                    Chaze is a blend of chess, maze and rock-paper-scissors.<br>
                    The "<span id="instr-plus"></span>" piece moves any number of squares horizontally or vertically.<br>
                    The "<span id="instr-star"></span>" piece can move any number of squares horizontally, vertically, or diagonally.<br>
                    The "<span id="instr-x"></span>" piece moves any number of squares diagonally.<br><br>

                    The players can make 2 things in each turn. They can move a piece or rotate a maze square. The player must move all the pieces from the base in 5 turns. If two of the player’s pieces are eaten, the last piece has only 5 turns left before it is also eliminated.<br><br>

                    A specific penalty has been added for players who are eliminated for failing to move their pieces out of the base within the five-turn limit. This change ensures that a player cannot accumulate eats and then intentionally get eliminated by this rule to preserve their score for the tournament.
                </p>
                <button id="closeInstructionsButton">Close</button>
            </div>
        </div>

        <!-- An overlay for showing temporary messages to the user -->
        <div id="message-overlay">
            <p id="message-text"></p>
        </div>

        <!-- The main container for the game board and UI -->
        <div id="gameContainer">
            <!-- Top section with turn info, controls, and rules -->
            <div id="info-area">
                <div id="gameInfo">
                    <div id="turn-display">Turn: Player 1</div>
                    <div id="timer-display"></div>
                     <div id="action-controls">
                        <button id="movePieceBtn" class="active">Move a Piece</button>
                        <button id="rotateSquareBtn">Rotate a Square</button>
                    </div>
                    <div id="turn-counter">Turn #: 1</div>
                </div>
                <div id="moves-counter">Moves Made: 0 / 2</div>
                <div id="last-stand-display"></div>
                <div id="rules-display">
                     <span id="rule-plus-1"></span> eats <span id="rule-x-1"></span> &nbsp;&nbsp;|&nbsp;&nbsp; <span id="rule-x-2"></span> eats <span id="rule-star-1"></span> &nbsp;&nbsp;|&nbsp;&nbsp; <span id="rule-star-2"></span> eats <span id="rule-plus-2"></span>
                </div>
            </div>
            <!-- Central area containing the board and surrounding player areas -->
            <div id="board-container">
                <!-- Graveyards for captured pieces -->
                <div id="player1-graveyard" class="graveyard"></div>
                <div id="player2-graveyard" class="graveyard"></div>
                <div id="player3-graveyard" class="graveyard"></div>
                <div id="player4-graveyard" class="graveyard"></div>
                <!-- Bases for starting pieces -->
                <div id="player1-base" class="base"></div>
                <div id="player2-base" class="base"></div>
                <div id="player3-base" class="base"></div>
                <div id="player4-base" class="base"></div>
                <!-- The game board itself -->
                <div id="game-board"></div>
            </div>
        </div>
    </div>

    <script>
        // Wait until the entire HTML document is loaded and parsed before running the script.
        document.addEventListener('DOMContentLoaded', () => {
            // --- Symbol Configuration ---
            // This is the single source of truth for piece symbols.
            // Change the character on the right to change the piece's appearance everywhere.
            const pieceSymbols = {
                "plus-piece": "⊕",
                "star-piece": "✴",
                "x-piece": "𐅡"
            };

            // --- DOM Element References ---
            const scalableContent = document.getElementById('scalable-content');
            const NATIVE_WIDTH = 1280; // The original design width
            const NATIVE_HEIGHT = 900; // The original design height

            // --- Game Scaling Logic ---
            // This function scales the game content to fit the browser window while maintaining aspect ratio.
            function scaleGame() {
                const availableWidth = window.innerWidth;
                const availableHeight = window.innerHeight;
                const scale = Math.min(availableWidth / NATIVE_WIDTH, availableHeight / NATIVE_HEIGHT);
                scalableContent.style.transform = `scale(${scale})`;
            }

            // Scale the game initially and add a listener to rescale on window resize.
            scaleGame();
            window.addEventListener('resize', scaleGame);

            // --- UI Element References ---
            const startButton = document.getElementById('startButton');
            const startScreen = document.getElementById('startScreen');
            const gameOverScreen = document.getElementById('gameOverScreen');
            const gameOverTitle = document.getElementById('gameOverTitle');
            const winnerInfo = document.getElementById('winner-info');
            const gameOverPrompt = document.getElementById('gameOverPrompt');
            const messageOverlay = document.getElementById('message-overlay');
            const messageText = document.getElementById('message-text');
            const gameContainer = document.getElementById('gameContainer');
            const playerCountSelect = document.getElementById('playerCount');
            const gameTypeSelect = document.getElementById('gameType');
            const turnTimeSelect = document.getElementById('turnTime');
            const timerDisplay = document.getElementById('timer-display');
            const lastStandDisplay = document.getElementById('last-stand-display');
            const boardContainer = document.getElementById('board-container');
            const instructionsButton = document.getElementById('instructionsButton');
            const instructionsScreen = document.getElementById('instructionsScreen');
            const closeInstructionsButton = document.getElementById('closeInstructionsButton');


            const botDifficultySelect = document.getElementById('botDifficulty');
            // We now target the container div for showing/hiding.
            const botDifficultyContainer = document.querySelector('.difficulty-selection'); 

            const botDifficultyLabel = document.querySelector('label[for="botDifficulty"]');
            const gameBoard = document.getElementById('game-board');
            const turnDisplay = document.getElementById('turn-display');
            const turnCounterDisplay = document.getElementById('turn-counter');
            const movesCounterDisplay = document.getElementById('moves-counter');
            const movePieceBtn = document.getElementById('movePieceBtn');
            const rotateSquareBtn = document.getElementById('rotateSquareBtn');

            // --- Game State Variables ---
            let numPlayers; // Total number of players in the game (2, 3, or 4)
            let isBotGame; // Boolean flag for 1-player mode against AI
            let botPlayers = []; // Array to store which players are bots
            let botDifficulty = 'easy'; // Bot difficulty setting
            let currentPlayer = 1; // The player whose turn it is
            let turnCount = 1; // The overall turn number
            let movesLeft = 2; // Actions remaining in the current turn
            let draggedPiece = null; // Reference to the piece element being dragged
            let selectedPiece = null; // Reference to the piece element selected for click-to-move
            let pieceMovedTwice = null; // Tracks if a single piece has been moved to enforce the "one piece moved twice or two pieces moved once" rule
            let currentAction = 'move'; // The currently selected action ('move' or 'rotate')
            let activePlayers = []; // An array of player numbers who are still in the game
            let eliminatedPlayers = []; // Tracks players who have been eliminated
            let lastStandTimers = {}; // Tracks countdowns for players with one piece left
            let playerEats = {}; // Tracks captures for each player for the current game
            let baseTurnCounter = {}; // Tracks turns a player has pieces in their base
            let messageTimeout; // A timer for hiding the message overlay
            let isGameOver = false; // Flag to stop actions after the game has ended
            let turnTimeLimit = Infinity; // Time limit for a turn in seconds
            let turnTimerInterval; // The interval timer for the countdown
            let timeLeft; // How much time is left in the current turn
            
            // Tournament State
            let isTournament = false;
            let tournamentGamesPlayed = 0;
            let tournamentScores = {};

            const playerColors = { 1: 'cyan', 2: 'yellow', 3: 'magenta', 4: 'green' };
            // The pieceTypes array now uses the internal names. The order defines the piece creation order.
            const pieceTypes = ["plus-piece", "x-piece", "star-piece"];
            // The pieceValues object uses the internal names as keys.
            const pieceValues = { "plus-piece": 3, "star-piece": 2, "x-piece": 1 }; // Values for AI and stalemate
            let players = {}; // An object to store data for each player's pieces
            
            // This function populates the symbols in the static HTML from the config object.
            function populateSymbols() {
                // Start Screen
                document.getElementById('p-plus').textContent = pieceSymbols['plus-piece'];
                document.getElementById('p-star').textContent = pieceSymbols['star-piece'];
                document.getElementById('p-x').textContent = pieceSymbols['x-piece'];

                // Instructions Screen
                document.getElementById('instr-plus').textContent = pieceSymbols['plus-piece'];
                document.getElementById('instr-star').textContent = pieceSymbols['star-piece'];
                document.getElementById('instr-x').textContent = pieceSymbols['x-piece'];

                // Rules Display
                document.getElementById('rule-plus-1').textContent = pieceSymbols['plus-piece'];
                document.getElementById('rule-plus-2').textContent = pieceSymbols['plus-piece'];
                document.getElementById('rule-x-1').textContent = pieceSymbols['x-piece'];
                document.getElementById('rule-x-2').textContent = pieceSymbols['x-piece'];
                document.getElementById('rule-star-1').textContent = pieceSymbols['star-piece'];
                document.getElementById('rule-star-2').textContent = pieceSymbols['star-piece'];
            }
            populateSymbols(); // Call on script load

            // --- Core Game Flow Functions ---
            
            // Show/hide bot difficulty based on player count
            function toggleBotDifficulty() {
                const playerCount = playerCountSelect.value;
                const isBotMode = ['1', '2-bots', '3-bots', '2v2'].includes(playerCount);
                botDifficultyContainer.style.display = isBotMode ? 'flex' : 'none';
            }
            playerCountSelect.addEventListener('change', toggleBotDifficulty);
            toggleBotDifficulty(); // Initial check

            // Attempts to put the browser into fullscreen mode.
            function enterFullScreen() {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
            }

            // Displays a message on the overlay for a set duration.
            function showMessage(message, duration = 2000) {
                clearTimeout(messageTimeout); // Clear any existing message timer
                messageText.textContent = message;
                messageOverlay.style.display = 'flex';
                messageTimeout = setTimeout(() => {
                    messageOverlay.style.display = 'none';
                }, duration);
            }

            // Hides the game and shows the game over screen with a winner message.
            function showGameOverScreen(gameWinnerMessage) {
                 isGameOver = true; // Set the game over flag
                 stopTurnTimer(); // Stop the timer when the game ends
                 
                 let title = "Game Over";
                 let info = gameWinnerMessage;
                 let prompt = "Click anywhere to Play Again";

                 if (isTournament) {
                    // Add current game's eats to tournament score
                    for(let i=1; i <= numPlayers; i++) {
                        tournamentScores[i] += playerEats[i] || 0;
                    }
                    tournamentGamesPlayed++;
                    
                    if (tournamentGamesPlayed < 3) {
                        title = `End of Game ${tournamentGamesPlayed}`;
                        info = `${gameWinnerMessage}<br><br><b>This Game's Eats:</b><br>`;
                        for(let i = 1; i <= numPlayers; i++) {
                            info += `Player ${i}: ${playerEats[i] || 0}<br>`;
                        }
                        info += `<br><b>Tournament Total Eats:</b><br>`;
                        for(let i = 1; i <= numPlayers; i++) {
                            info += `Player ${i}: ${tournamentScores[i] || 0}<br>`;
                        }
                        prompt = "Click anywhere to Start Next Game";
                    } else {
                        // Tournament is over, find the winner
                        let maxEats = -1;
                        let tournamentWinners = [];
                        for(let i = 1; i <= numPlayers; i++) {
                            if (tournamentScores[i] > maxEats) {
                                maxEats = tournamentScores[i];
                                tournamentWinners = [i];
                            } else if (tournamentScores[i] === maxEats) {
                                tournamentWinners.push(i);
                            }
                        }
                        
                        title = "Tournament Over!";
                        if(tournamentWinners.length > 1) {
                            info = `It's a draw between Players ${tournamentWinners.join(' & ')}!`;
                        } else {
                            info = `Player ${tournamentWinners[0]} is the Tournament Winner!`;
                        }

                        info += `<br><br><b>Final Tournament Eats:</b><br>`;
                        for(let i = 1; i <= numPlayers; i++) {
                            info += `Player ${i}: ${tournamentScores[i] || 0}<br>`;
                        }
                        prompt = "Click anywhere to Play Again";
                    }

                 } else {
                    // Single game over
                    info += `<br><br><b>Final Eats:</b><br>`;
                    for(let i = 1; i <= numPlayers; i++) {
                        info += `Player ${i}: ${playerEats[i] || 0}<br>`;
                    }
                 }


                 setTimeout(() => { // Small delay to allow the final move to be seen
                    gameOverTitle.textContent = title;
                    winnerInfo.innerHTML = info; // Use innerHTML to render <br> tags
                    gameOverPrompt.textContent = prompt;
                    // gameContainer.style.display = 'none'; // THIS LINE IS THE PROBLEM
                    gameOverScreen.style.display = 'flex';
                }, 500);
            }

            // Event listener to return to the start screen from the game over screen.
            gameOverScreen.addEventListener('click', () => {
                 if (isTournament && tournamentGamesPlayed < 3) {
                    // Start the next game in the tournament
                    gameOverScreen.style.display = 'none';
                    initializeGame();
                } else {
                    // Return to the main menu
                    gameOverScreen.style.display = 'none';
                    startScreen.style.display = 'flex';
                    gameContainer.style.display = 'none'; // Hide the game container when returning to main menu
                }
            });

            // Event listener for the "Start Game" button.
            startButton.addEventListener('click', () => {
                const playerCountValue = playerCountSelect.value;
                const gameTypeValue = gameTypeSelect.value;
                
                isTournament = (gameTypeValue === 'tournament');
                if (isTournament) {
                    tournamentGamesPlayed = 0;
                    tournamentScores = {};
                }

                isBotGame = false;
                botPlayers = [];
                botDifficulty = botDifficultySelect.value;

                if (playerCountValue === '1') {
                    numPlayers = 2;
                    isBotGame = true;
                    botPlayers = [2];
                } else if (playerCountValue === '2-bots') {
                    numPlayers = 3;
                    isBotGame = true;
                    botPlayers = [2, 3];
                } else if (playerCountValue === '3-bots') {
                    numPlayers = 4;
                    isBotGame = true;
                    botPlayers = [2, 3, 4];
                } else if (playerCountValue === '2v2') {
                    numPlayers = 4;
                    isBotGame = true;
                    botPlayers = [3, 4];
                }
                else {
                    numPlayers = parseInt(playerCountValue);
                }
                
                if (isTournament) {
                     for(let i=1; i<= numPlayers; i++){
                        tournamentScores[i] = 0;
                    }
                }

                const timeValue = turnTimeSelect.value;
                turnTimeLimit = timeValue === "Infinite" ? Infinity : parseInt(timeValue);

                startScreen.style.display = 'none';
                enterFullScreen();
                initializeGame();
            });

            // --- Instructions Screen Listeners ---
            instructionsButton.addEventListener('click', () => {
                instructionsScreen.style.display = 'flex';
            });

            closeInstructionsButton.addEventListener('click', () => {
                instructionsScreen.style.display = 'none';
            });

            instructionsScreen.addEventListener('click', (e) => {
                // Only close if the dark background itself is clicked, not the content box
                if (e.target === instructionsScreen) {
                    instructionsScreen.style.display = 'none';
                }
            });

            // --- Game Initialization ---
            // Sets up the game board, pieces, and resets all state variables for a single game.
            function initializeGame() {
                // Show the game container
                gameContainer.style.display = 'flex';

                // Reset game state
                isGameOver = false;
                activePlayers = [];
                eliminatedPlayers = []; // Reset eliminated players
                lastStandTimers = {}; // Reset last stand timers
                playerEats = {}; // Reset eats counters for the new game
                baseTurnCounter = {}; // Reset base turn counters
                lastStandDisplay.textContent = ''; // Clear last stand display
                currentPlayer = 1;
                turnCount = 1;
                movesLeft = 2;
                pieceMovedTwice = null;
                for (let i = 1; i <= numPlayers; i++) {
                    activePlayers.push(i);
                    baseTurnCounter[i] = 0; // Initialize base counter for each player
                    playerEats[i] = 0; // Initialize eats for each player for this game
                }
                
                // Clear the board and player areas for restart scenarios
                gameBoard.innerHTML = '';
                boardContainer.querySelectorAll('.eats-counter').forEach(el => el.remove());
                for (let i = 1; i <= 4; i++) {
                    const base = document.getElementById(`player${i}-base`);
                    const graveyard = document.getElementById(`player${i}-graveyard`);
                    if(base) base.innerHTML = '';
                    if(graveyard) graveyard.innerHTML = '';
                    
                    if (i <= numPlayers) {
                         // Create and add eats counter
                        const eatsCounter = document.createElement('div');
                        eatsCounter.id = `player${i}-eats-counter`;
                        eatsCounter.className = 'eats-counter';
                        boardContainer.appendChild(eatsCounter);
                        updateEatsDisplay(i);
                    }
                }

                // --- Board Generation ---
                // Create the 9 main squares, each containing 9 sub-squares.
                for (let i = 0; i < 9; i++) {
                    const mainSquare = document.createElement('div');
                    mainSquare.classList.add('main-square');
                    mainSquare.dataset.mainSquareId = i; // For rotation tracking
                    for (let j = 0; j < 9; j++) {
                        const subSquare = document.createElement('div');
                        subSquare.classList.add('sub-square');
                        subSquare.dataset.mainSquare = i; // Store parent square ID
                        subSquare.dataset.subSquare = j;  // Store local square ID
                        mainSquare.appendChild(subSquare);
                    }
                    gameBoard.appendChild(mainSquare);

                    // --- Wall Generation (within each main square) ---
                    // Randomly places 3 walls in each 3x3 main square.
                    const subSquares = Array.from(mainSquare.children);
                    // Map of each sub-square index to its adjacent neighbors.
                    const neighborsMap = {
                        0: [1, 3], 1: [0, 2, 4], 2: [1, 5],
                        3: [0, 4, 6], 4: [1, 3, 5, 7], 5: [2, 4, 8],
                        6: [3, 7], 7: [4, 6, 8], 8: [5, 7]
                    };

                    const walls = [];
                    // Pick the first wall completely randomly.
                    let s1_idx = Math.floor(Math.random() * 9);
                    walls.push(s1_idx);

                    // Pick the second wall from the neighbors of the first.
                    let s2_options = neighborsMap[s1_idx];
                    let s2_idx = s2_options[Math.floor(Math.random() * s2_options.length)];
                    walls.push(s2_idx);
                    
                    // Pick the third wall from the combined neighbors of the first two, ensuring it's not one of them.
                    let s3_options = [...new Set([...neighborsMap[s1_idx], ...neighborsMap[s2_idx]])];
                    s3_options = s3_options.filter(idx => !walls.includes(idx));
                    let s3_idx = s3_options[Math.floor(Math.random() * s3_options.length)];
                    walls.push(s3_idx);

                    // Add the 'wall' class to the selected sub-squares.
                    walls.forEach(wallIndex => {
                        subSquares[wallIndex].classList.add('wall');
                    });
                }

                // --- Piece and Player Area Generation ---
                for (let i = 1; i <= 4; i++) {
                    players[i] = []; // Initialize the player's piece array
                    const base = document.getElementById(`player${i}-base`);
                    const graveyard = document.getElementById(`player${i}-graveyard`);
                    const eatsCounter = document.getElementById(`player${i}-eats-counter`);
                    
                    // If the player is not in the current game, hide their areas.
                    if (i > numPlayers) {
                        base.style.display = 'none';
                        graveyard.style.display = 'none';
                        if(eatsCounter) eatsCounter.style.display = 'none';
                        continue;
                    }
                     base.style.display = 'grid';
                     graveyard.style.display = 'flex';
                     if(eatsCounter) eatsCounter.style.display = 'block';
                    
                    const pieces = [];
                    // Create 3 pieces for the player.
                    for (let j = 0; j < 3; j++) {
                        const baseSquare = document.createElement('div');
                        baseSquare.classList.add('base-square');
                        const pieceElement = document.createElement('div');
                        pieceElement.classList.add('piece', `player${i}`);
                        const pieceType = pieceTypes[j]; // Get internal name
                        pieceElement.textContent = pieceSymbols[pieceType]; // Set display symbol
                        pieceElement.dataset.player = i;
                        pieceElement.dataset.type = pieceType; // Store internal name
                        pieceElement.draggable = true;
                        
                        // Create the move counter element for the piece.
                        const moveCounter = document.createElement('div');
                        moveCounter.classList.add('move-counter');
                        moveCounter.textContent = '0';
                        pieceElement.appendChild(moveCounter);

                        // Store piece data in the global 'players' object for easy access.
                        players[i].push({ 
                            player: i, 
                            type: pieceType, 
                            element: pieceElement,
                            movesThisTurn: 0 
                        });
                        baseSquare.appendChild(pieceElement);
                        pieces.push(baseSquare);
                    }

                    // Arrange pieces in the base with one empty square.
                    const blankDiv = () => document.createElement('div');
                    switch (i) {
                        case 1: 
                            base.appendChild(pieces[0]); base.appendChild(pieces[1]);
                            base.appendChild(pieces[2]); base.appendChild(blankDiv());
                            break;
                        case 2:
                            base.appendChild(pieces[0]); base.appendChild(pieces[1]);
                            base.appendChild(blankDiv()); base.appendChild(pieces[2]);
                            break;
                        case 3:
                            base.appendChild(pieces[0]); base.appendChild(blankDiv());
                            base.appendChild(pieces[1]); base.appendChild(pieces[2]);
                            break;
                        case 4:
                            base.appendChild(blankDiv()); base.appendChild(pieces[0]);
                            base.appendChild(pieces[1]); base.appendChild(pieces[2]);
                            break;
                    }
                }
                
                // Set up all necessary event listeners and update the UI.
                addEventListeners();
                updateTurnDisplay();
                updateMovesDisplay();
                turnCounterDisplay.textContent = `Turn #: ${turnCount}`;
                startTurnTimer(); // Start timer for the first turn
            }
            
            // --- Timer Controls ---
            function startTurnTimer() {
                stopTurnTimer(); // Clear any existing timer
                if (turnTimeLimit === Infinity) {
                    timerDisplay.textContent = ''; // Don't show a timer
                    return;
                }
                timeLeft = turnTimeLimit;
                timerDisplay.textContent = timeLeft;
                turnTimerInterval = setInterval(() => {
                    timeLeft--;
                    timerDisplay.textContent = timeLeft;
                    if (timeLeft <= 0) {
                        nextTurn(); // End turn if time runs out
                    }
                }, 1000);
            }

            function stopTurnTimer() {
                clearInterval(turnTimerInterval);
            }

            // --- Event Listener Setup ---
            function addEventListeners() {
                // Main listeners for clicks and action buttons.
                gameContainer.addEventListener('click', handleGameClick);
                movePieceBtn.addEventListener('click', () => setAction('move'));
                rotateSquareBtn.addEventListener('click', () => setAction('rotate'));

                // --- Drag and Drop Logic ---
                gameContainer.addEventListener('dragstart', (e) => {
                    // Only allow dragging if it's a piece, the action is 'move', and it's the current player's piece.
                    if (currentAction !== 'move' || !e.target.classList.contains('piece')) {
                        e.preventDefault();
                        return;
                    }
                    if (parseInt(e.target.dataset.player) !== currentPlayer) {
                         e.preventDefault();
                         return;
                    }

                    draggedPiece = e.target;
                    if (selectedPiece) { // Deselect any piece selected for click-to-move
                        selectedPiece.classList.remove('selected');
                        selectedPiece = null;
                    }
                    setTimeout(() => e.target.classList.add('dragging'), 0); // Add dragging class after a delay
                });

                gameContainer.addEventListener('dragend', (e) => {
                    // Clean up after dragging ends.
                    if(draggedPiece) {
                        draggedPiece.classList.remove('dragging');
                        draggedPiece = null;
                    }
                });

                // Prevent the default behavior to allow a drop.
                gameContainer.addEventListener('dragover', (e) => {
                    e.preventDefault(); 
                });

                gameContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedPiece) {
                        const subSquareTarget = e.target.closest('.sub-square');
                        const baseSquareTarget = e.target.closest('.base-square');

                        // If dropped on a game board square, attempt a move.
                        if (subSquareTarget) {
                            const mainId = parseInt(subSquareTarget.dataset.mainSquare);
                            const subId = parseInt(subSquareTarget.dataset.subSquare);
                            movePiece(draggedPiece, mainId, subId);
                        // If dropped on a base square, attempt to return to base.
                        } else if (baseSquareTarget) {
                            const base = baseSquareTarget.closest('.base');
                            if (base) {
                                const baseOwnerId = parseInt(base.id.replace('player', '').replace('-base', ''));
                                if (baseOwnerId === currentPlayer) { // Can only return to your own base
                                    movePiece(draggedPiece, -1, -1); // Use -1 as a flag for returning to base
                                }
                            }
                        }
                        // Clean up after drop.
                        draggedPiece.classList.remove('dragging');
                        draggedPiece = null;
                    }
                });
            }
            
            // Sets the current action ('move' or 'rotate') and updates the UI buttons.
            function setAction(action) {
                currentAction = action;
                movePieceBtn.classList.toggle('active', action === 'move');
                rotateSquareBtn.classList.toggle('active', action === 'rotate');
                // Deselect any piece if switching to rotate mode.
                if (action === 'rotate' && selectedPiece) {
                    selectedPiece.classList.remove('selected');
                    selectedPiece = null;
                }
            }

            // Handles all click events within the game container.
            function handleGameClick(e) {
                if (isGameOver) return;
                const target = e.target;
                // If in 'rotate' mode, try to rotate the clicked main square.
                if (currentAction === 'rotate') {
                    const mainSquare = target.closest('.main-square');
                    if (mainSquare) {
                        rotateMainSquare(mainSquare);
                    }
                    return;
                }
                
                // --- Click-to-Move Logic ---
                if (currentAction === 'move') {
                    const clickedPiece = target.closest('.piece');
                    // If a piece belonging to the current player is clicked...
                    if (clickedPiece && parseInt(clickedPiece.dataset.player) === currentPlayer) {
                        if (selectedPiece) {
                            selectedPiece.classList.remove('selected');
                        }
                        // Deselect if clicking the same piece again.
                        if (selectedPiece === clickedPiece) {
                            selectedPiece = null; 
                        } else {
                            // Otherwise, select the new piece.
                            selectedPiece = clickedPiece;
                            selectedPiece.classList.add('selected');
                        }
                    // If a piece is already selected and a square is clicked...
                    } else if (selectedPiece) {
                        const subSquareTarget = target.closest('.sub-square');
                        const baseSquareTarget = target.closest('.base-square');

                        // If a board square is clicked, try to move there.
                        if (subSquareTarget) {
                            const mainId = parseInt(subSquareTarget.dataset.mainSquare);
                            const subId = parseInt(subSquareTarget.dataset.subSquare);
                            movePiece(selectedPiece, mainId, subId);
                        // If a base square is clicked, try to return to base.
                        } else if (baseSquareTarget) {
                             const base = baseSquareTarget.closest('.base');
                             if (base && parseInt(base.id.replace('player', '').replace('-base', '')) === currentPlayer) {
                                movePiece(selectedPiece, -1, -1);
                             }
                        }
                    }
                }
            }
            
            // --- Core Game Mechanics ---

            // Animates a piece moving from its current location to a new parent square.
            function animatePieceMovement(piece, newParent) {
                return new Promise(resolve => {
                    const startRect = piece.getBoundingClientRect();

                    // To get the end position, temporarily move the piece, measure, and move it back.
                    const originalParent = piece.parentElement;
                    const pieceToEat = newParent.firstChild;
                    if (pieceToEat) newParent.removeChild(pieceToEat); // Temporarily remove piece to be eaten
                    newParent.appendChild(piece);
                    const endRect = piece.getBoundingClientRect();
                    originalParent.appendChild(piece); // Put piece back
                    if (pieceToEat) newParent.appendChild(pieceToEat); // Put eaten piece back for a moment

                    const clone = piece.cloneNode(true);
                    clone.classList.remove('selected'); // Don't show selection border during animation
                    clone.style.position = 'absolute';
                    clone.style.margin = '0';
                    clone.style.zIndex = '1000'; // Ensure it's on top
                    clone.style.left = `${startRect.left}px`;
                    clone.style.top = `${startRect.top}px`;
                    clone.style.width = `${startRect.width}px`;
                    clone.style.height = `${startRect.height}px`;
                    clone.style.transition = 'left 0.3s ease-in-out, top 0.3s ease-in-out';
                    
                    document.body.appendChild(clone); // Append to body to ignore parent transforms
                    piece.style.visibility = 'hidden'; // Hide the original piece

                    // In the next frame, set the new position to trigger the transition
                    requestAnimationFrame(() => {
                        clone.style.left = `${endRect.left}px`;
                        clone.style.top = `${endRect.top}px`;
                    });

                    // After the animation duration, clean up and resolve the promise
                    setTimeout(() => {
                        document.body.removeChild(clone);
                        piece.style.visibility = 'visible'; // Show the original piece again
                        resolve(); // Signal that the animation is complete
                    }, 300); // This duration must match the CSS transition duration
                });
            }

            function eliminateByBaseRule(playerId) {
                if (!activePlayers.includes(playerId)) return;
                
                // Set the player's eats for this game to 0.
                playerEats[playerId] = 0;
                updateEatsDisplay(playerId);

                // If in a tournament, reset their entire tournament score to 0.
                if (isTournament) {
                    tournamentScores[playerId] = 0;
                }

                // Move ALL remaining pieces of that player to their graveyard.
                const graveyard = document.getElementById(`player${playerId}-graveyard`);
                players[playerId].forEach(pieceData => {
                    // Only move pieces that aren't already in the graveyard.
                    if (!findPiecePosition(pieceData.element).inGraveyard) {
                        graveyard.appendChild(pieceData.element);
                    }
                });

                // Now call the standard elimination checker with the specific reason.
                const reason = "The player must move all the pieces away from the base in 5 turns or the player is eliminated.";
                checkForElimination(playerId, reason);
            }

            function eliminateByTimer(playerId) {
                if (!activePlayers.includes(playerId)) return;
                
                // Find the player's last piece
                const lastPieceData = players[playerId].find(p => !findPiecePosition(p.element).inGraveyard);
                if (lastPieceData) {
                    const graveyard = document.getElementById(`player${playerId}-graveyard`);
                    const timerElement = graveyard.querySelector('.last-stand-timer');
                    if(timerElement) timerElement.remove(); // Remove the timer display

                    graveyard.appendChild(lastPieceData.element); // Move last piece to graveyard
                    showMessage(`Player ${playerId}'s last stand is over!`);
                    checkForElimination(playerId); // Process the elimination
                }
            }

            // Checks if a player has lost all their pieces.
            function checkForElimination(playerId, reason = null) {
                if (!activePlayers.includes(playerId)) return;

                const graveyard = document.getElementById(`player${playerId}-graveyard`);
                if (!graveyard) return;

                const pieceCountInGraveyard = graveyard.querySelectorAll('.piece').length;

                // Condition for starting the Last Stand timer
                if (pieceCountInGraveyard === 2 && lastStandTimers[playerId] === undefined) {
                    lastStandTimers[playerId] = 5; // Start 5-turn timer
                    const timerElement = document.createElement('div');
                    timerElement.classList.add('last-stand-timer');
                    timerElement.textContent = lastStandTimers[playerId];
                    graveyard.appendChild(timerElement);
                    lastStandDisplay.textContent = `Player ${playerId} Last Stand!`;
                }
                
                // Condition for final elimination
                if (pieceCountInGraveyard >= 3) {
                    if (lastStandTimers[playerId] !== undefined) {
                        delete lastStandTimers[playerId]; // Clear timer if they get eliminated normally
                        lastStandDisplay.textContent = ''; // Clear display
                    }
                    eliminatedPlayers.push(playerId);
                    
                    const playerIndex = activePlayers.indexOf(playerId);
                    if (playerIndex > -1) {
                        activePlayers.splice(playerIndex, 1);
                    }
                    
                    // Build the elimination message, adding the reason if it exists.
                    let message = `Player ${playerId} has been eliminated!`;
                    if (reason) {
                        message += `\n${reason}`;
                    }
                    showMessage(message);

                    // Check for a winner.
                    if (activePlayers.length === 1) {
                        showGameOverScreen(`Player ${activePlayers[0]} is the winner!`);
                    } else if (activePlayers.length < 1) {
                        showGameOverScreen("It's a draw!");
                    }
                }
            }


            // The main function that handles moving a piece element to a new square.
            async function movePiece(pieceElement, mainSquareId, subSquareId) {
                if (isGameOver) return;
                const pieceData = getPieceObject(pieceElement);
                if (!pieceData) return;

                // Validate the move before proceeding.
                const moveValidation = isValidMove(pieceData, mainSquareId, subSquareId);
                if (!moveValidation.valid) {
                    showMessage(moveValidation.reason);
                    return;
                }
                
                // --- Execute the Move ---
                if (mainSquareId === -1) { // Moving back to base
                    const base = document.getElementById(`player${pieceData.player}-base`);
                    const emptyBaseSquare = Array.from(base.children).find(child => child.classList.contains('base-square') && !child.firstChild);
                    if (emptyBaseSquare) {
                        await animatePieceMovement(pieceElement, emptyBaseSquare);
                        emptyBaseSquare.appendChild(pieceElement);
                    } else {
                        showMessage("Your base is full!");
                        return;
                    }
                } else { // Moving to a board square
                    const targetSquare = document.querySelector(`[data-main-square='${mainSquareId}'][data-sub-square='${subSquareId}']`);
                    const targetPiece = targetSquare.firstChild;

                    // Animate first
                    await animatePieceMovement(pieceElement, targetSquare);

                    // If there was a piece to capture, handle it
                    if (targetPiece) {
                        const targetPieceData = getPieceObject(targetPiece);
                        if(canEat(pieceData, targetPieceData)){
                             playerEats[currentPlayer]++;
                             updateEatsDisplay(currentPlayer);
                             const graveyard = document.getElementById(`player${targetPieceData.player}-graveyard`);
                             if (graveyard) {
                                 targetPiece.draggable = false;
                                 graveyard.appendChild(targetPiece); // Move target to its graveyard
                                 checkForElimination(targetPieceData.player);
                             }
                        } else {
                             showMessage("Cannot eat that piece!");
                             return; 
                        }
                    }
                    
                    // Now, place the attacker in the target square
                    targetSquare.appendChild(pieceElement);
                }
                
                // Deselect the piece after a successful move.
                if (selectedPiece) {
                    selectedPiece.classList.remove('selected');
                    selectedPiece = null;
                }

                // --- Update Game State Post-Move ---
                pieceData.movesThisTurn++;
                pieceElement.querySelector('.move-counter').textContent = pieceData.movesThisTurn;
                movesLeft--;
                updateMovesDisplay();

                // Logic for the "one piece twice or two pieces once" rule.
                if(pieceMovedTwice && pieceElement !== pieceMovedTwice.element) {
                    movesLeft = 0;
                } else if(pieceMovedTwice && pieceElement === pieceMovedTwice.element) {
                    movesLeft = 0;
                } else if (movesLeft === 1) {
                    pieceMovedTwice = { element: pieceElement };
                } 
                
                if(movesLeft <= 0) nextTurn();
            }

            // Helper function to get the main square ID for a player's home corner.
            function getHomeMainSquareId(player) {
                switch(player) {
                    case 1: return 0; // Top-left
                    case 2: return 2; // Top-right
                    case 3: return 6; // Bottom-left
                    case 4: return 8; // Bottom-right
                    default: return null;
                }
            }
            
            // Checks if the path between two coordinates is blocked by a wall or another piece.
            function isPathClear(curTotalRow, curTotalCol, targetTotalRow, targetTotalCol, ignoredSquares = []) {
                const rowDiff = targetTotalRow - curTotalRow;
                const colDiff = targetTotalCol - curTotalCol;
                // Determine the direction of movement (1, -1, or 0).
                const rowStep = Math.sign(rowDiff);
                const colStep = Math.sign(colDiff);

                let currentRow = curTotalRow + rowStep;
                let currentCol = curTotalCol + colStep;

                // Iterate through each square along the path.
                while (currentRow !== targetTotalRow || currentCol !== targetTotalCol) {
                    // Convert the absolute row/col back to main/sub square IDs.
                    const mainRow = Math.floor(currentRow / 3);
                    const mainCol = Math.floor(currentCol / 3);
                    const subRow = currentRow % 3;
                    const subCol = currentCol % 3;
                    const mainId = mainRow * 3 + mainCol;
                    const subId = subRow * 3 + subCol;
                    
                    const intermediateSquare = document.querySelector(`[data-main-square='${mainId}'][data-sub-square='${subId}']`);
                    if (ignoredSquares.includes(intermediateSquare)) {
                        // This square is being virtually ignored (e.g., for rotation check), so skip it.
                    } else if (intermediateSquare && (intermediateSquare.firstChild || intermediateSquare.classList.contains('wall'))) {
                        return { clear: false, blockingSquare: intermediateSquare }; // Path is blocked
                    }

                    currentRow += rowStep;
                    currentCol += colStep;
                }

                return { clear: true }; // Path is clear
            }


            // Comprehensive move validation function.
            function isValidMove(piece, mainId, subId, options = {}) {
                const { ignoredSquares = [] } = options;
                 const currentPos = findPiecePosition(piece.element);
                 
                 // --- Case 1: Moving back to base ---
                 if (mainId === -1) {
                    if (!currentPos.onBoard) return {valid: false, reason: "Cannot move to base."}
                    const homeMainSquareId = getHomeMainSquareId(piece.player);
                    if (currentPos.main !== homeMainSquareId) return { valid: false, reason: "Can only return to base from your home square."};
                    return { valid: true };
                 }

                 const targetSquare = document.querySelector(`[data-main-square='${mainId}'][data-sub-square='${subId}']`);
                 
                 // --- Case 2: Moving from base onto the board ---
                 if (!currentPos.onBoard && !currentPos.inGraveyard) {
                     const homeMainSquareId = getHomeMainSquareId(piece.player);
                     if (mainId !== homeMainSquareId) return { valid: false, reason: "Can only enter on your home square." };
                     if(targetSquare.classList.contains('wall')) return { valid: false, reason: "Cannot move onto a wall." };
                     if(targetSquare.firstChild && !canEat(piece, getPieceObject(targetSquare.firstChild))) return {valid: false, reason: "Cannot eat that piece."}
                     return { valid: true };
                 } 
                 
                 // --- Case 3: Moving on the board ---
                 if (currentPos.onBoard) {
                    if(targetSquare.classList.contains('wall')) return { valid: false, reason: "Cannot move onto a wall." };
                    if(targetSquare.firstChild && !canEat(piece, getPieceObject(targetSquare.firstChild))) return { valid: false, reason: "Cannot eat that piece." };

                    // Convert main/sub IDs to an absolute 9x9 grid coordinate system for easier path calculation.
                    const {mainRow: curMainRow, mainCol: curMainCol, subRow: curSubRow, subCol: curSubCol} = getCoordsFromIds(currentPos.main, currentPos.sub);
                    const {mainRow: targetMainRow, mainCol: targetMainCol, subRow: targetSubRow, subCol: targetSubCol} = getCoordsFromIds(mainId, subId);

                    const curTotalRow = curMainRow * 3 + curSubRow;
                    const curTotalCol = curMainCol * 3 + curSubCol;
                    const targetTotalRow = targetMainRow * 3 + targetSubRow;
                    const targetTotalCol = targetMainCol * 3 + targetSubCol;
                    
                    if (curTotalRow === targetTotalRow && curTotalCol === targetTotalCol) return { valid: false, reason: "Must move to a different square." };

                    // Calculate row/column difference to check move type.
                    const totalRowDiff = Math.abs(targetTotalRow - curTotalRow);
                    const totalColDiff = Math.abs(targetTotalCol - curTotalCol);

                    // Check if the move matches the piece's allowed movement type using internal names.
                    let moveTypeValid = false;
                    if(piece.type === "plus-piece") moveTypeValid = (totalRowDiff > 0 && totalColDiff === 0) || (totalRowDiff === 0 && totalColDiff > 0); // Rook
                    if(piece.type === "x-piece") moveTypeValid = totalRowDiff > 0 && totalRowDiff === totalColDiff; // Bishop
                    if(piece.type === "star-piece") moveTypeValid = (totalRowDiff > 0 && totalColDiff === 0) || (totalRowDiff === 0 && totalColDiff > 0) || (totalRowDiff > 0 && totalRowDiff === totalColDiff); // Queen
                    
                    if (!moveTypeValid) return { valid: false, reason: "This piece cannot move like that." };
                    
                    const pathCheck = isPathClear(curTotalRow, curTotalCol, targetTotalRow, targetTotalCol, ignoredSquares);
                    if (!pathCheck.clear) return { valid: false, reason: "Path is blocked by a piece or wall.", blockingSquare: pathCheck.blockingSquare };

                    return { valid: true };
                 }
                 
                 return { valid: false, reason: "Piece is not in a valid location." }; // Fallback
            }

            // Checks the "rock-paper-scissors" capture logic using internal names.
            function canEat(attacker, defender) {
                if (!attacker || !defender) return false;
                if (attacker.player === defender.player) return false; // Cannot eat your own piece
                if(attacker.type === 'plus-piece' && defender.type === 'x-piece') return true;
                if(attacker.type === 'x-piece' && defender.type === 'star-piece') return true;
                if(attacker.type === 'star-piece' && defender.type === 'plus-piece') return true;
                return false;
            }
            
            // Rotates the sub-squares within a main square 90 degrees clockwise.
            function rotateMainSquare(mainSquareElement) {
                if (isGameOver) return;
                const subSquares = Array.from(mainSquareElement.children);
                // Define the new order of sub-squares after a clockwise rotation.
                const newOrder = [
                    subSquares[6], subSquares[3], subSquares[0],
                    subSquares[7], subSquares[4], subSquares[1],
                    subSquares[8], subSquares[5], subSquares[2]
                ];
                
                mainSquareElement.innerHTML = ''; // Clear the main square
                // Append the sub-squares in their new order and update their dataset index.
                newOrder.forEach((square, index) => {
                    square.dataset.subSquare = index; 
                    mainSquareElement.appendChild(square);
                });
                
                // A rotation counts as one move.
                movesLeft--;
                updateMovesDisplay();
                if(movesLeft <= 0) nextTurn();
            }
            
            // --- Helper Functions ---

            // Retrieves the data object for a piece from the 'players' object using its DOM element.
            function getPieceObject(pieceElement) {
                if (!pieceElement) return null;
                const player = parseInt(pieceElement.dataset.player);
                if (players[player]) {
                    return players[player].find(p => p.element === pieceElement);
                }
                return null;
            }
            
            // Finds the location of a piece element (on board, in base, or in graveyard).
            function findPiecePosition(pieceElement) {
                const parent = pieceElement.parentElement;
                if (parent.classList.contains('sub-square')) {
                    return { onBoard: true, main: parseInt(parent.dataset.mainSquare), sub: parseInt(parent.dataset.subSquare) };
                } else if (parent.classList.contains('base-square')) { 
                     const base = parent.closest('.base');
                     return { onBoard: false, inGraveyard: false, base: parseInt(base.id.replace('player','').replace('-base','')) };
                }
                return { onBoard: false, inGraveyard: true }; // Assumed to be in graveyard if not elsewhere
            }
            
            // Converts main and sub square IDs into row/column coordinates.
            function getCoordsFromIds(mainId, subId){
                return { mainRow: Math.floor(mainId / 3), mainCol: mainId % 3, subRow: Math.floor(subId / 3), subCol: subId % 3 };
            }
            
            // --- UI Update Functions ---
            
            function updateTurnDisplay() {
                turnDisplay.textContent = `Turn: Player ${currentPlayer}`;
                turnDisplay.style.color = playerColors[currentPlayer];
            }

            function updateMovesDisplay() {
                movesCounterDisplay.textContent = `Moves Made: ${2 - movesLeft} / 2`;
            }

            function updateEatsDisplay(playerId) {
                const counterElement = document.getElementById(`player${playerId}-eats-counter`);
                if (counterElement) {
                    counterElement.textContent = `Eats: ${playerEats[playerId]}`;
                }
            }

            // --- Turn Management ---

            // Advances the game to the next player's turn.
            function nextTurn() {
                if (isGameOver) return;
                // Allow turn to end if time runs out, even if moves are left
                if (movesLeft > 0 && timeLeft > 0) return;
                stopTurnTimer(); // Stop the current timer

                // Last Stand Countdown Logic for the player whose turn is ENDING
                if (lastStandTimers[currentPlayer] !== undefined) {
                    lastStandTimers[currentPlayer]--;
                    const graveyard = document.getElementById(`player${currentPlayer}-graveyard`);
                    const timerElement = graveyard.querySelector('.last-stand-timer');
                    if(timerElement) timerElement.textContent = lastStandTimers[currentPlayer];

                    if (lastStandTimers[currentPlayer] <= 0) {
                        eliminateByTimer(currentPlayer);
                        if(isGameOver) return; // Stop if the game ended
                    }
                }
                
                // Check for the new base rule for the player whose turn is ENDING.
                const playerPieces = players[currentPlayer];
                const piecesInBase = playerPieces.some(p => {
                    const pos = findPiecePosition(p.element);
                    return !pos.onBoard && !pos.inGraveyard; // Check if it's in the base
                });

                if (piecesInBase) {
                    baseTurnCounter[currentPlayer]++;
                } else {
                    // If they have no pieces in base, the counter resets.
                    baseTurnCounter[currentPlayer] = 0;
                }

                // Now check if they should be eliminated.
                if (baseTurnCounter[currentPlayer] >= 5) {
                    eliminateByBaseRule(currentPlayer);
                    if(isGameOver) return; // Stop if the game ended
                }


                if (activePlayers.length <= 1) return;

                if (selectedPiece) {
                    selectedPiece.classList.remove('selected');
                    selectedPiece = null;
                }

                // Find the next active player in the rotation.
                const currentPlayerIndex = activePlayers.indexOf(currentPlayer);
                const nextPlayerIndex = (currentPlayerIndex + 1) % activePlayers.length;
                currentPlayer = activePlayers[nextPlayerIndex];

                // Update Last Stand display for the NEW current player
                if (lastStandTimers[currentPlayer] !== undefined) {
                    lastStandDisplay.textContent = `Player ${currentPlayer} Last Stand!`;
                } else {
                    lastStandDisplay.textContent = '';
                }

                // Reset the move counter for the new current player's pieces.
                if (players[currentPlayer]) {
                    players[currentPlayer].forEach(p => {
                        p.movesThisTurn = 0;
                        if (p.element.parentElement && !p.element.parentElement.closest('.graveyard')) {
                            p.element.querySelector('.move-counter').textContent = '0';
                        }
                    });
                }
                
                // Increment the overall turn counter after a full round of players.
                if (currentPlayerIndex === activePlayers.length - 1 || activePlayers.length === numPlayers) {
                     turnCount++;
                }
                
                // Reset turn state.
                movesLeft = 2;
                pieceMovedTwice = null;
                
                // Update UI and check for stalemate.
                updateTurnDisplay();
                updateMovesDisplay();
                turnCounterDisplay.textContent = `Turn #: ${turnCount}`;
                setAction('move'); // Default action is 'move'
                startTurnTimer(); // Start timer for the new turn
                checkStalemate();

                // If it's a bot game and now a bot's turn, trigger its logic.
                if (isBotGame && botPlayers.includes(currentPlayer)) {
                    playBotTurn();
                }
            }
            
            function formatStalemateMessage(tieBreakerResult) {
                let message = "<b>Stalemate!</b> No more captures were possible on the board.<br>";
                message += tieBreakerResult; // Add the specific reason for the result

                const survivors = activePlayers.map(p => `Player ${p}`).join(', ');
                message += `<br><br><b>Survivors:</b> ${survivors}`;

                if (eliminatedPlayers.length > 0) {
                    const eliminated = eliminatedPlayers.map(p => `Player ${p}`).join(', ');
                    message += `<br><b>Eliminated:</b> ${eliminated}`;
                }
                return message;
            }

            // Checks for a stalemate condition where no more captures are possible.
            function checkStalemate() {
                if (activePlayers.length <= 1) return;
                const activePieces = [];
                // Get a list of all pieces not in a graveyard.
                activePlayers.forEach(p => {
                    players[p].forEach(pieceData => {
                        if (!findPiecePosition(pieceData.element).inGraveyard) {
                            activePieces.push(pieceData);
                        }
                    });
                });

                // Check if any piece can eat any other piece.
                let possibleCapture = false;
                for (let i = 0; i < activePieces.length; i++) {
                    for (let j = 0; j < activePieces.length; j++) {
                        if (i === j) continue;
                        if (canEat(activePieces[i], activePieces[j])) {
                            possibleCapture = true;
                            break;
                        }
                    }
                    if (possibleCapture) break;
                }

                // If no captures are possible, the game ends in a stalemate.
                if (!possibleCapture) {
                    // --- Stalemate Tie-Breaker Logic ---
                    let playerPieceCount = {};
                    let playerHighestValue = {};
                    
                    activePlayers.forEach(p => {
                        playerPieceCount[p] = 0;
                        playerHighestValue[p] = 0;
                    });
                    
                    // Count pieces and find the highest value piece for each player.
                    activePieces.forEach(p => {
                       playerPieceCount[p.player]++;
                       if(pieceValues[p.type] > playerHighestValue[p.player]){
                           playerHighestValue[p.player] = pieceValues[p.type];
                       }
                    });

                    // Tie-breaker 1: Player with the most pieces wins.
                    let maxPieces = -1;
                    let playersWithMaxPieces = [];
                    activePlayers.forEach(p => {
                         if(playerPieceCount[p] > maxPieces){
                            maxPieces = playerPieceCount[p];
                            playersWithMaxPieces = [p];
                         } else if (playerPieceCount[p] === maxPieces) {
                            playersWithMaxPieces.push(p);
                         }
                    });

                    if(playersWithMaxPieces.length === 1) {
                         const mainMsg = `Player ${playersWithMaxPieces[0]} wins due to the 'Most Pieces' tie-breaker.`;
                         showGameOverScreen(formatStalemateMessage(mainMsg));
                         return;
                    }

                    // Tie-breaker 2: If still tied, player with the highest value piece wins.
                    let maxValue = -1;
                    let winningPlayers = [];
                     playersWithMaxPieces.forEach(p => {
                        if(playerHighestValue[p] > maxValue) {
                            maxValue = playerHighestValue[p];
                            winningPlayers = [p];
                        } else if (playerHighestValue[p] === maxValue) {
                            winningPlayers.push(p);
                        }
                    });

                    if(winningPlayers.length === 1) {
                        const mainMsg = `Player ${winningPlayers[0]} wins due to the 'Highest Value Piece' tie-breaker.`;
                        showGameOverScreen(formatStalemateMessage(mainMsg));
                    } else {
                        // If still tied, it's a draw.
                        const mainMsg = "The game is a draw as all tie-breakers were met.";
                        showGameOverScreen(formatStalemateMessage(mainMsg));
                    }
                }
            }

            // --- Bot (AI) Logic ---

            function getBotTargets() {
                // Bots prioritize human players. If none are left, they target other bots.
                const humanPlayers = activePlayers.filter(p => !botPlayers.includes(p));
                if (humanPlayers.length > 0) {
                    return humanPlayers;
                } else {
                    return activePlayers.filter(p => p !== currentPlayer); // Target remaining bots
                }
            }

            // Helper: Try to move a piece from the base onto the board.
            async function botAttemptMoveFromBase() {
                const botPiecesInBase = players[currentPlayer].filter(p => {
                    const pos = findPiecePosition(p.element);
                    return !pos.onBoard && !pos.inGraveyard;
                });
                if (botPiecesInBase.length > 0) {
                    const pieceToMove = botPiecesInBase[0];
                    const homeMainSquareId = getHomeMainSquareId(currentPlayer);
                    const homeMainSquare = document.querySelector(`[data-main-square-id='${homeMainSquareId}']`);
                    const targetSubSquares = Array.from(homeMainSquare.children);
                    const validTargets = targetSubSquares.filter(square => !square.classList.contains('wall') && (!square.firstChild || canEat(pieceToMove, getPieceObject(square.firstChild))));

                    if (validTargets.length > 0) {
                        const targetSquare = validTargets[Math.floor(Math.random() * validTargets.length)];
                        await movePiece(pieceToMove.element, parseInt(targetSquare.dataset.mainSquare), parseInt(targetSquare.dataset.subSquare));
                        return true;
                    }
                }
                return false;
            }

            // Helper: Try to move a piece on the board to a random empty square.
            async function botAttemptMoveOnBoard() {
                const botPiecesOnBoard = players[currentPlayer].filter(p => findPiecePosition(p.element).onBoard);
                if (botPiecesOnBoard.length > 0) {
                    const shuffledPieces = botPiecesOnBoard.sort(() => 0.5 - Math.random());
                    const allSubSquares = Array.from(document.querySelectorAll('.sub-square'));

                    for (const piece of shuffledPieces) {
                        const emptyValidMoves = allSubSquares.filter(sq => !sq.firstChild && isValidMove(piece, parseInt(sq.dataset.mainSquare), parseInt(sq.dataset.subSquare)).valid);
                        if (emptyValidMoves.length > 0) {
                            const targetSquare = emptyValidMoves[Math.floor(Math.random() * emptyValidMoves.length)];
                            await movePiece(piece.element, parseInt(targetSquare.dataset.mainSquare), parseInt(targetSquare.dataset.subSquare));
                            return true;
                        }
                    }
                }
                return false;
            }

            // EASY: Move from base, then move randomly on board.
            async function playEasyBotTurn() {
                if (await botAttemptMoveFromBase()) return true;
                if (await botAttemptMoveOnBoard()) return true;
                return false;
            }
            
            // MEDIUM: Look for best capture, then escape threats, then play like Easy.
            async function playMediumBotTurn() {
                const botPiecesOnBoard = players[currentPlayer].filter(p => findPiecePosition(p.element).onBoard);
                const opponentPlayers = getBotTargets();
                
                let possibleCaptures = [];
                for (const botPiece of botPiecesOnBoard) {
                    for (const playerNum of opponentPlayers) {
                         for (const opponentPiece of players[playerNum]) {
                            if (!findPiecePosition(opponentPiece.element).onBoard) continue;
                            const opponentPos = findPiecePosition(opponentPiece.element);
                            if (canEat(botPiece, opponentPiece) && isValidMove(botPiece, opponentPos.main, opponentPos.sub).valid) {
                                possibleCaptures.push({
                                    attacker: botPiece.element,
                                    targetPos: opponentPos,
                                    value: pieceValues[opponentPiece.type] || 0
                                });
                            }
                        }
                    }
                }

                if (possibleCaptures.length > 0) {
                    possibleCaptures.sort((a, b) => b.value - a.value);
                    const bestCapture = possibleCaptures[0];
                    await movePiece(bestCapture.attacker, bestCapture.targetPos.main, bestCapture.targetPos.sub);
                    return true;
                }

                 for (const botPiece of botPiecesOnBoard) {
                    const botPos = findPiecePosition(botPiece.element);
                    let isThreatened = false;
                     for (const playerNum of opponentPlayers) {
                        for (const opponentPiece of players[playerNum]) {
                            if (!findPiecePosition(opponentPiece.element).onBoard) continue;
                            if (canEat(opponentPiece, botPiece) && isValidMove(opponentPiece, botPos.main, botPos.sub).valid) {
                                isThreatened = true;
                                break;
                            }
                        }
                        if (isThreatened) break;
                    }

                    if (isThreatened) {
                        const allSubSquares = Array.from(document.querySelectorAll('.sub-square'));
                        const validMoves = allSubSquares.filter(sq => !sq.firstChild && isValidMove(botPiece, parseInt(sq.dataset.mainSquare), parseInt(sq.dataset.subSquare)).valid);
                        if (validMoves.length > 0) {
                            const targetSquare = validMoves[Math.floor(Math.random() * validMoves.length)];
                            await movePiece(botPiece.element, parseInt(targetSquare.dataset.mainSquare), parseInt(targetSquare.dataset.subSquare));
                            return true;
                        }
                    }
                }

                if (await botAttemptMoveFromBase()) return true;
                if (await botAttemptMoveOnBoard()) return true;
                return false;
            }

            // HARD: Plans one move ahead and considers rotating squares to enable attacks.
            async function playHardBotTurn() {
                const botPiecesOnBoard = players[currentPlayer].filter(p => findPiecePosition(p.element).onBoard);
                const opponentPlayers = getBotTargets();
                let allOpponentPieces = [];
                opponentPlayers.forEach(pNum => {
                    allOpponentPieces = allOpponentPieces.concat(players[pNum].filter(p => findPiecePosition(p.element).onBoard));
                });
                
                let bestCaptureMove = { score: -Infinity };
                let bestRotationalCapture = { score: -Infinity };

                for (const botPiece of botPiecesOnBoard) {
                    for (const opponentPiece of allOpponentPieces) {
                        const opponentPos = findPiecePosition(opponentPiece.element);
                        if (canEat(botPiece, opponentPiece) && isValidMove(botPiece, opponentPos.main, opponentPos.sub).valid) {
                            let score = pieceValues[opponentPiece.type];
                            
                            let isRecapturable = false;
                            for(const avenger of allOpponentPieces) {
                                if (avenger === opponentPiece) continue;
                                if (canEat(avenger, botPiece) && isValidMove(avenger, opponentPos.main, opponentPos.sub).valid) {
                                    isRecapturable = true;
                                    break;
                                }
                            }
                            if (isRecapturable) {
                                score -= pieceValues[botPiece.type];
                            }

                            if (score > bestCaptureMove.score) {
                                bestCaptureMove = {
                                    score: score,
                                    action: 'move',
                                    attacker: botPiece.element,
                                    targetPos: opponentPos
                                };
                            }
                        }
                    }
                }
                
                for (const botPiece of botPiecesOnBoard) {
                    for (const opponentPiece of allOpponentPieces) {
                        if (canEat(botPiece, opponentPiece)) {
                            const opponentPos = findPiecePosition(opponentPiece.element);
                            const moveCheck = isValidMove(botPiece, opponentPos.main, opponentPos.sub);
                            if (!moveCheck.valid && moveCheck.blockingSquare && moveCheck.blockingSquare.classList.contains('wall')) {
                                const blockingWall = moveCheck.blockingSquare;
                                const mainSquareIdToRotate = parseInt(blockingWall.dataset.mainSquare);
                                const pathCheckAfterRotation = isValidMove(botPiece, opponentPos.main, opponentPos.sub, { ignoredSquares: [blockingWall] });
                                if (pathCheckAfterRotation.valid) {
                                    const score = pieceValues[opponentPiece.type];
                                    if(score > bestRotationalCapture.score) {
                                        bestRotationalCapture = {
                                            score: score,
                                            action: 'rotate',
                                            mainSquareToRotate: document.querySelector(`[data-main-square-id='${mainSquareIdToRotate}']`)
                                        };
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (bestCaptureMove.score > 0 || bestRotationalCapture.score > 0) {
                    if (bestCaptureMove.score >= bestRotationalCapture.score) {
                        await movePiece(bestCaptureMove.attacker, bestCaptureMove.targetPos.main, bestCaptureMove.targetPos.sub);
                        return true;
                    } else {
                        rotateMainSquare(bestRotationalCapture.mainSquareToRotate);
                        return true;
                    }
                }
                
                return await playMediumBotTurn();
            }


            // This function contains the logic for the computer player's turn.
            async function playBotTurn() {
                // The main action-taking function for the bot.
                const doBotAction = async () => {
                    if (movesLeft <= 0 || !activePlayers.includes(currentPlayer) || isGameOver) return;

                    let actionTaken = false;
                    // Route to the correct difficulty logic.
                    if (botDifficulty === 'easy') {
                        actionTaken = await playEasyBotTurn();
                    } else if (botDifficulty === 'medium') {
                        actionTaken = await playMediumBotTurn();
                    } else if (botDifficulty === 'hard') {
                        actionTaken = await playHardBotTurn();
                    }
                    
                    // Fallback: If no other action was taken, rotate a random square.
                    if (!actionTaken) {
                        const allMainSquares = Array.from(document.querySelectorAll('.main-square'));
                        const randomMainSquare = allMainSquares[Math.floor(Math.random() * allMainSquares.length)];
                        rotateMainSquare(randomMainSquare);
                    }
                };

                // Use timeouts to create a delay, making the bot's moves feel more natural.
                setTimeout(async () => {
                    await doBotAction(); // Perform the first action.
                    if (movesLeft > 0 && !isGameOver) {
                        setTimeout(async () => {
                           await doBotAction(); // Perform the second action if the turn isn't over.
                        }, 800);
                    }
                }, 800);
            }
        });
    </script>

</body>
</html>

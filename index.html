<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategic Conquest</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #333;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        #scalable-content {
            width: 1280px; /* Native resolution width */
            height: 900px; /* Native resolution height */
            position: relative;
            transform-origin: center center;
        }

        #startScreen {
            text-align: center;
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #333;
            z-index: 100;
        }

        #startScreen h1 {
            font-size: 3em;
        }

        #playerCount, #startButton {
            font-size: 1.5em;
            margin: 10px;
            padding: 10px;
        }
        
        #gameContainer {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        
        #info-area {
            width: 800px;
            text-align: center;
            margin-top: 20px;
        }

        #gameInfo {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
            font-size: 1.2em;
        }
        
        #action-controls button {
            font-size: 1em;
            padding: 10px 15px;
            margin: 0 5px;
            border: 2px solid #aaa;
            background-color: #555;
            color: #fff;
            cursor: pointer;
            border-radius: 5px;
        }
        
        #action-controls button.active {
            background-color: #ddd;
            color: #333;
            border-color: #fff;
        }

        #turn-display {
            font-weight: bold;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px #000;
        }
        
        #moves-counter {
            font-size: 1.1em;
            color: #ccc;
            margin-top: 5px;
        }
        
        #rules-display {
            margin-top: 10px;
            margin-bottom: 20px;
            padding: 5px;
            border-radius: 5px;
            background-color: rgba(0, 0, 0, 0.2);
            font-size: 1.1em;
            color: #ddd;
            text-align: center;
        }

        #rules-display span {
            font-weight: bold;
            font-size: 1.5em;
            vertical-align: middle;
            display: inline-block;
            margin: 0 5px;
        }

        #board-container {
            position: relative;
            width: 614px;
            height: 614px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .base {
            position: absolute;
            width: 150px; 
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            z-index: 10;
            pointer-events: none; /* This makes the container transparent to mouse events */
        }

        #player1-base { top: -100px; left: -100px; }
        #player2-base { top: -100px; right: -100px; }
        #player3-base { bottom: -100px; left: -100px; }
        #player4-base { bottom: -100px; right: -100px; }

        .base-square {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            pointer-events: auto; /* This makes the squares and pieces clickable again */
        }

        #player1-base .base-square { background-color: cyan; }
        #player2-base .base-square { background-color: yellow; }
        #player3-base .base-square { background-color: magenta; }
        #player4-base .base-square { background-color: green; }
        
        .graveyard {
            position: absolute;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 5px;
            width: 60px;
            height: 200px;
            border: 2px dashed #777;
            border-radius: 5px;
            z-index: 20;
        }
        
        #player1-graveyard { top: 20px; left: 20px; }
        #player2-graveyard { top: 20px; right: 20px; }
        #player3-graveyard { bottom: 20px; left: 20px; }
        #player4-graveyard { bottom: 20px, right: 20px; }


        .graveyard .piece {
            width: 45px;
            height: 45px;
            font-size: 0.9em;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .graveyard .piece .move-counter { display: none; }


        #game-board {
            display: grid;
            width: 600px;
            height: 600px;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            background-color: #666;
            padding: 5px;
            border: 2px solid #999;
        }

        .main-square {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            background-color: white;
        }

        .sub-square {
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            font-weight: bold;
            cursor: pointer;
        }
        
        .wall {
            background-color: #5a5a5a;
            cursor: not-allowed;
        }
        
        .piece {
            position: relative;
            border-radius: 50%;
            width: 80%;
            height: 80%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: black;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            cursor: grab;
        }
        
        .piece.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .move-counter {
            position: absolute;
            bottom: 1px;
            right: 4px;
            font-size: 0.5em;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.7);
            color: black;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
        }


        .player1 { background-color: cyan; }
        .player2 { background-color: yellow; }
        .player3 { background-color: magenta; }
        .player4 { background-color: green; }

    </style>
</head>
<body>
    <div id="scalable-content">
        <div id="startScreen">
            <h1>Strategic Conquest</h1>
            <p>The "+" piece moves any number of squares horizontally or vertically.</p>
            <p>The "✴" piece can move any number of squares horizontally, vertically, or diagonally.</p>
            <p>The "×" piece moves any number of squares diagonally.</p>
            <label for="playerCount">Select Number of Players:</label>
            <select id="playerCount">
                <option value="1">1 Player (vs Bot)</option>
                <option value="2">2 Players</option>
                <option value="3">3 Players</option>
                <option value="4">4 Players</option>
            </select>
            <button id="startButton">Start Game</button>
        </div>

        <div id="player1-graveyard" class="graveyard"></div>
        <div id="player2-graveyard" class="graveyard"></div>
        <div id="player3-graveyard" class="graveyard"></div>
        <div id="player4-graveyard" class="graveyard"></div>

        <div id="gameContainer">
            <div id="info-area">
                <div id="gameInfo">
                    <div id="turn-display">Turn: Player 1</div>
                     <div id="action-controls">
                        <button id="movePieceBtn" class="active">Move a Piece</button>
                        <button id="rotateSquareBtn">Rotate a Square</button>
                    </div>
                    <div id="turn-counter">Turn #: 1</div>
                </div>
                <div id="moves-counter">Moves Made: 0 / 2</div>
                <div id="rules-display">
                    <span>+</span> eats <span>×</span> &nbsp;&nbsp;|&nbsp;&nbsp; <span>×</span> eats <span>✴</span> &nbsp;&nbsp;|&nbsp;&nbsp; <span>✴</span> eats <span>+</span>
                </div>
            </div>
            <div id="board-container">
                <div id="player1-base" class="base"></div>
                <div id="player2-base" class="base"></div>
                <div id="player3-base" class="base"></div>
                <div id="player4-base" class="base"></div>
                <div id="game-board"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const scalableContent = document.getElementById('scalable-content');
            const NATIVE_WIDTH = 1280;
            const NATIVE_HEIGHT = 900;

            function scaleGame() {
                const availableWidth = window.innerWidth;
                const availableHeight = window.innerHeight;
                const scale = Math.min(availableWidth / NATIVE_WIDTH, availableHeight / NATIVE_HEIGHT);
                scalableContent.style.transform = `scale(${scale})`;
            }

            // Initial and resize scaling
            scaleGame();
            window.addEventListener('resize', scaleGame);

            const startButton = document.getElementById('startButton');
            const startScreen = document.getElementById('startScreen');
            const gameContainer = document.getElementById('gameContainer');
            const playerCountSelect = document.getElementById('playerCount');
            const gameBoard = document.getElementById('game-board');
            const turnDisplay = document.getElementById('turn-display');
            const turnCounterDisplay = document.getElementById('turn-counter');
            const movesCounterDisplay = document.getElementById('moves-counter');
            const movePieceBtn = document.getElementById('movePieceBtn');
            const rotateSquareBtn = document.getElementById('rotateSquareBtn');

            let numPlayers;
            let isBotGame;
            let currentPlayer = 1;
            let turnCount = 1;
            let movesLeft = 2;
            let draggedPiece = null;
            let pieceMovedTwice = null;
            let currentAction = 'move';
            let activePlayers = [];

            const playerColors = { 1: 'cyan', 2: 'yellow', 3: 'magenta', 4: 'green' };
            const pieceTypes = ["+", "×", "✴"];
            let players = {};

            startButton.addEventListener('click', () => {
                numPlayers = parseInt(playerCountSelect.value);
                isBotGame = numPlayers === 1;
                if (isBotGame) numPlayers = 2;

                startScreen.style.display = 'none';
                gameContainer.style.display = 'flex';
                initializeGame();
            });

            function initializeGame() {
                activePlayers = [];
                for (let i = 1; i <= numPlayers; i++) {
                    activePlayers.push(i);
                }
                
                // Clear board for restart scenarios
                gameBoard.innerHTML = '';
                for (let i = 1; i <= 4; i++) {
                    document.getElementById(`player${i}-base`).innerHTML = '';
                    document.getElementById(`player${i}-graveyard`).innerHTML = '';
                }


                for (let i = 0; i < 9; i++) {
                    const mainSquare = document.createElement('div');
                    mainSquare.classList.add('main-square');
                    mainSquare.dataset.mainSquareId = i;
                    for (let j = 0; j < 9; j++) {
                        const subSquare = document.createElement('div');
                        subSquare.classList.add('sub-square');
                        subSquare.dataset.mainSquare = i;
                        subSquare.dataset.subSquare = j;
                        mainSquare.appendChild(subSquare);
                    }
                    gameBoard.appendChild(mainSquare);

                    // --- Wall Generation ---
                    const subSquares = Array.from(mainSquare.children);
                    const neighborsMap = {
                        0: [1, 3], 1: [0, 2, 4], 2: [1, 5],
                        3: [0, 4, 6], 4: [1, 3, 5, 7], 5: [2, 4, 8],
                        6: [3, 7], 7: [4, 6, 8], 8: [5, 7]
                    };

                    const walls = [];
                    let s1_idx = Math.floor(Math.random() * 9);
                    walls.push(s1_idx);

                    let s2_options = neighborsMap[s1_idx];
                    let s2_idx = s2_options[Math.floor(Math.random() * s2_options.length)];
                    walls.push(s2_idx);
                    
                    let s3_options = [...new Set([...neighborsMap[s1_idx], ...neighborsMap[s2_idx]])];
                    s3_options = s3_options.filter(idx => !walls.includes(idx));
                    
                    let s3_idx = s3_options[Math.floor(Math.random() * s3_options.length)];
                    walls.push(s3_idx);

                    walls.forEach(wallIndex => {
                        subSquares[wallIndex].classList.add('wall');
                    });
                }

                for (let i = 1; i <= 4; i++) {
                    players[i] = [];
                    const base = document.getElementById(`player${i}-base`);
                    const graveyard = document.getElementById(`player${i}-graveyard`);
                    if (i > numPlayers) {
                        base.style.display = 'none';
                        graveyard.style.display = 'none';
                        continue;
                    }
                     base.style.display = 'grid';
                     graveyard.style.display = 'flex';
                    
                    const pieces = [];
                    for (let j = 0; j < 3; j++) {
                        const baseSquare = document.createElement('div');
                        baseSquare.classList.add('base-square');
                        const pieceElement = document.createElement('div');
                        pieceElement.classList.add('piece', `player${i}`);
                        pieceElement.textContent = pieceTypes[j];
                        pieceElement.dataset.player = i;
                        pieceElement.dataset.type = pieceTypes[j];
                        pieceElement.draggable = true;
                        
                        const moveCounter = document.createElement('div');
                        moveCounter.classList.add('move-counter');
                        moveCounter.textContent = '0';
                        pieceElement.appendChild(moveCounter);

                        players[i].push({ 
                            player: i, 
                            type: pieceTypes[j], 
                            element: pieceElement,
                            movesThisTurn: 0 
                        });
                        baseSquare.appendChild(pieceElement);
                        pieces.push(baseSquare);
                    }

                    const blankDiv = () => document.createElement('div');
                    switch (i) {
                        case 1: 
                            base.appendChild(pieces[0]); base.appendChild(pieces[1]);
                            base.appendChild(pieces[2]); base.appendChild(blankDiv());
                            break;
                        case 2:
                            base.appendChild(pieces[0]); base.appendChild(pieces[1]);
                            base.appendChild(blankDiv()); base.appendChild(pieces[2]);
                            break;
                        case 3:
                            base.appendChild(pieces[0]); base.appendChild(blankDiv());
                            base.appendChild(pieces[1]); base.appendChild(pieces[2]);
                            break;
                        case 4:
                            base.appendChild(blankDiv()); base.appendChild(pieces[0]);
                            base.appendChild(pieces[1]); base.appendChild(pieces[2]);
                            break;
                    }
                }
                
                addEventListeners();
                updateTurnDisplay();
                updateMovesDisplay();
            }

            function addEventListeners() {
                gameContainer.addEventListener('click', handleGameClick);
                movePieceBtn.addEventListener('click', () => setAction('move'));
                rotateSquareBtn.addEventListener('click', () => setAction('rotate'));

                gameContainer.addEventListener('dragstart', (e) => {
                    if (currentAction !== 'move' || !e.target.classList.contains('piece')) {
                        e.preventDefault();
                        return;
                    }
                    if (parseInt(e.target.dataset.player) !== currentPlayer) {
                         e.preventDefault();
                         return;
                    }

                    draggedPiece = e.target;
                    setTimeout(() => e.target.classList.add('dragging'), 0);
                });

                gameContainer.addEventListener('dragend', (e) => {
                    if(draggedPiece) {
                        draggedPiece.classList.remove('dragging');
                        draggedPiece = null;
                    }
                });

                gameContainer.addEventListener('dragover', (e) => {
                    e.preventDefault(); 
                });

                gameContainer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedPiece) {
                        const subSquareTarget = e.target.closest('.sub-square');
                        const baseSquareTarget = e.target.closest('.base-square');

                        if (subSquareTarget) {
                            const mainId = parseInt(subSquareTarget.dataset.mainSquare);
                            const subId = parseInt(subSquareTarget.dataset.subSquare);
                            movePiece(draggedPiece, mainId, subId);
                        } else if (baseSquareTarget) {
                            const base = baseSquareTarget.closest('.base');
                            if (base) {
                                const baseOwnerId = parseInt(base.id.replace('player', '').replace('-base', ''));
                                if (baseOwnerId === currentPlayer) {
                                    movePiece(draggedPiece, -1, -1);
                                }
                            }
                        }
                        draggedPiece.classList.remove('dragging');
                        draggedPiece = null;
                    }
                });
            }
            
            function setAction(action) {
                currentAction = action;
                movePieceBtn.classList.toggle('active', action === 'move');
                rotateSquareBtn.classList.toggle('active', action === 'rotate');
            }

            function handleGameClick(e) {
                if (currentAction === 'rotate') {
                    const mainSquare = e.target.closest('.main-square');
                    if (mainSquare) {
                        rotateMainSquare(mainSquare);
                    }
                }
            }
            
            function checkForElimination(playerId) {
                if (!activePlayers.includes(playerId)) return;

                const graveyard = document.getElementById(`player${playerId}-graveyard`);
                if (graveyard && graveyard.children.length >= 3) {
                    const playerIndex = activePlayers.indexOf(playerId);
                    if (playerIndex > -1) {
                        activePlayers.splice(playerIndex, 1);
                    }
                    alert(`Player ${playerId} has been eliminated!`);

                    if (activePlayers.length === 1) {
                        setTimeout(() => {
                            alert(`Player ${activePlayers[0]} is the last one standing and wins the game!`);
                            location.reload();
                        }, 100);
                    } else if (activePlayers.length < 1) {
                        setTimeout(() => {
                            alert(`It's a draw!`);
                            location.reload();
                        }, 100);
                    }
                }
            }

            function movePiece(pieceElement, mainSquareId, subSquareId) {
                const pieceData = getPieceObject(pieceElement);
                if (!pieceData) return;

                if (!isValidMove(pieceData, mainSquareId, subSquareId)) {
                    alert('Invalid move!');
                    return;
                }
                
                if (mainSquareId === -1) {
                    const base = document.getElementById(`player${pieceData.player}-base`);
                    const emptyBaseSquare = Array.from(base.children).find(child => child.classList.contains('base-square') && !child.firstChild);
                    if (emptyBaseSquare) {
                        emptyBaseSquare.appendChild(pieceElement);
                    } else {
                        alert("Your base is full!");
                        return;
                    }
                } else {
                    const targetSquare = document.querySelector(`[data-main-square='${mainSquareId}'][data-sub-square='${subSquareId}']`);
                    if (targetSquare.firstChild) {
                        const targetPiece = targetSquare.firstChild;
                        const targetPieceData = getPieceObject(targetPiece);
                        if(canEat(pieceData, targetPieceData)) {
                            const graveyard = document.getElementById(`player${targetPieceData.player}-graveyard`);
                            if (graveyard) {
                                targetPiece.draggable = false;
                                graveyard.appendChild(targetPiece);
                                checkForElimination(targetPieceData.player);
                            }
                        } else {
                            alert("Cannot eat that piece!");
                            return;
                        }
                    }
                    targetSquare.appendChild(pieceElement);
                }
                
                pieceData.movesThisTurn++;
                pieceElement.querySelector('.move-counter').textContent = pieceData.movesThisTurn;
                movesLeft--;
                updateMovesDisplay();

                if(pieceMovedTwice && pieceElement !== pieceMovedTwice.element) {
                    movesLeft = 0;
                } else if(pieceMovedTwice && pieceElement === pieceMovedTwice.element) {
                    movesLeft = 0;
                } else if (movesLeft === 1) {
                    pieceMovedTwice = { element: pieceElement };
                } 
                
                if(movesLeft <= 0) nextTurn();
            }

            function getHomeMainSquareId(player) {
                switch(player) {
                    case 1: return 0;
                    case 2: return 2;
                    case 3: return 6;
                    case 4: return 8;
                    default: return null;
                }
            }

            function isPathClear(curTotalRow, curTotalCol, targetTotalRow, targetTotalCol) {
                const rowDiff = targetTotalRow - curTotalRow;
                const colDiff = targetTotalCol - curTotalCol;
                const rowStep = Math.sign(rowDiff);
                const colStep = Math.sign(colDiff);

                let currentRow = curTotalRow + rowStep;
                let currentCol = curTotalCol + colStep;

                while (currentRow !== targetTotalRow || currentCol !== targetTotalCol) {
                    const mainRow = Math.floor(currentRow / 3);
                    const mainCol = Math.floor(currentCol / 3);
                    const subRow = currentRow % 3;
                    const subCol = currentCol % 3;
                    const mainId = mainRow * 3 + mainCol;
                    const subId = subRow * 3 + subCol;
                    
                    const intermediateSquare = document.querySelector(`[data-main-square='${mainId}'][data-sub-square='${subId}']`);
                    if (intermediateSquare && (intermediateSquare.firstChild || intermediateSquare.classList.contains('wall'))) {
                        return false; // Path is blocked by a piece or a wall
                    }

                    currentRow += rowStep;
                    currentCol += colStep;
                }

                return true; // Path is clear
            }


            function isValidMove(piece, mainId, subId) {
                 const currentPos = findPiecePosition(piece.element);
                 
                 if (!currentPos.onBoard && !currentPos.inGraveyard) {
                     const homeMainSquareId = getHomeMainSquareId(piece.player);
                     if (mainId !== homeMainSquareId) return false;

                     const targetSquare = document.querySelector(`[data-main-square='${mainId}'][data-sub-square='${subId}']`);
                     if(targetSquare.classList.contains('wall')) return false;

                     return true;
                 } else if (currentPos.onBoard) {
                    if (mainId === -1) {
                        const homeMainSquareId = getHomeMainSquareId(piece.player);
                        return currentPos.main === homeMainSquareId;
                    } else {
                        const targetSquare = document.querySelector(`[data-main-square='${mainId}'][data-sub-square='${subId}']`);
                        if(targetSquare.classList.contains('wall')) return false;

                        const {mainRow: curMainRow, mainCol: curMainCol, subRow: curSubRow, subCol: curSubCol} = getCoordsFromIds(currentPos.main, currentPos.sub);
                        const {mainRow: targetMainRow, mainCol: targetMainCol, subRow: targetSubRow, subCol: targetSubCol} = getCoordsFromIds(mainId, subId);

                        const curTotalRow = curMainRow * 3 + curSubRow;
                        const curTotalCol = curMainCol * 3 + curSubCol;
                        const targetTotalRow = targetMainRow * 3 + targetSubRow;
                        const targetTotalCol = targetMainCol * 3 + targetSubCol;
                        
                        const totalRowDiff = Math.abs(targetTotalRow - curTotalRow);
                        const totalColDiff = Math.abs(targetTotalCol - curTotalCol);

                        let moveTypeValid = false;
                        if(piece.type === "+") moveTypeValid = (totalRowDiff > 0 && totalColDiff === 0) || (totalRowDiff === 0 && totalColDiff > 0);
                        if(piece.type === "×") moveTypeValid = totalRowDiff > 0 && totalRowDiff === totalColDiff;
                        if(piece.type === "✴") moveTypeValid = (totalRowDiff > 0 && totalColDiff === 0) || (totalRowDiff === 0 && totalColDiff > 0) || (totalRowDiff > 0 && totalRowDiff === totalColDiff);
                        
                        if (!moveTypeValid) return false;

                        if (!isPathClear(curTotalRow, curTotalCol, targetTotalRow, targetTotalCol)) return false;

                        return true;
                    }
                 }
                 return false;
            }

            function canEat(attacker, defender) {
                if (!attacker || !defender) return false;
                if (attacker.player === defender.player) return false;
                if(attacker.type === '+' && defender.type === '×') return true;
                if(attacker.type === '×' && defender.type === '✴') return true;
                if(attacker.type === '✴' && defender.type === '+') return true;
                return false;
            }
            
            function rotateMainSquare(mainSquareElement) {
                const subSquares = Array.from(mainSquareElement.children);
                const newOrder = [
                    subSquares[6], subSquares[3], subSquares[0],
                    subSquares[7], subSquares[4], subSquares[1],
                    subSquares[8], subSquares[5], subSquares[2]
                ];
                
                mainSquareElement.innerHTML = '';
                newOrder.forEach((square, index) => {
                    square.dataset.subSquare = index; 
                    mainSquareElement.appendChild(square);
                });
                
                movesLeft--;
                updateMovesDisplay();
                if(movesLeft <= 0) nextTurn();
            }
            
            function getPieceObject(pieceElement) {
                if (!pieceElement) return null;
                const player = parseInt(pieceElement.dataset.player);
                if (players[player]) {
                    return players[player].find(p => p.element === pieceElement);
                }
                return null;
            }
            
            function findPiecePosition(pieceElement) {
                const parent = pieceElement.parentElement;
                if (parent.classList.contains('sub-square')) {
                    return { onBoard: true, main: parseInt(parent.dataset.mainSquare), sub: parseInt(parent.dataset.subSquare) };
                } else if (parent.classList.contains('base-square')) { 
                     const base = parent.closest('.base');
                     return { onBoard: false, inGraveyard: false, base: parseInt(base.id.replace('player','').replace('-base','')) };
                }
                return { onBoard: false, inGraveyard: true };
            }
            
            function getCoordsFromIds(mainId, subId){
                return { mainRow: Math.floor(mainId / 3), mainCol: mainId % 3, subRow: Math.floor(subId / 3), subCol: subId % 3 };
            }
            
            function updateTurnDisplay() {
                turnDisplay.textContent = `Turn: Player ${currentPlayer}`;
                turnDisplay.style.color = playerColors[currentPlayer];
            }

            function updateMovesDisplay() {
                movesCounterDisplay.textContent = `Moves Made: ${2 - movesLeft} / 2`;
            }

            function nextTurn() {
                if (movesLeft > 0 || activePlayers.length <= 1) return; 

                const finishingPlayer = currentPlayer;
                
                const currentPlayerIndex = activePlayers.indexOf(currentPlayer);
                const nextPlayerIndex = (currentPlayerIndex + 1) % activePlayers.length;
                currentPlayer = activePlayers[nextPlayerIndex];

                if (players[currentPlayer]) {
                    players[currentPlayer].forEach(p => {
                        p.movesThisTurn = 0;
                        if (findPiecePosition(p.element).inGraveyard === false) {
                            p.element.querySelector('.move-counter').textContent = '0';
                        }
                    });
                }
                
                turnCount++;
                movesLeft = 2;
                pieceMovedTwice = null;
                
                updateTurnDisplay();
                updateMovesDisplay();
                turnCounterDisplay.textContent = `Turn #: ${turnCount}`;
                setAction('move');
                checkStalemate();

                if (isBotGame && currentPlayer === 2) {
                    playBotTurn();
                }
            }

            function checkStalemate() {
                const activePieces = [];
                activePlayers.forEach(p => {
                    players[p].forEach(pieceData => {
                        if (!findPiecePosition(pieceData.element).inGraveyard) {
                            activePieces.push(pieceData);
                        }
                    });
                });

                let possibleCapture = false;
                for (let i = 0; i < activePieces.length; i++) {
                    for (let j = 0; j < activePieces.length; j++) {
                        if (i === j) continue;
                        if (canEat(activePieces[i], activePieces[j])) {
                            possibleCapture = true;
                            break;
                        }
                    }
                    if (possibleCapture) break;
                }

                if (!possibleCapture) {
                    let playerPieceCount = {};
                    let playerHighestValue = {};
                    const pieceValues = { '+': 3, '✴': 2, '×': 1 };

                    activePlayers.forEach(p => {
                        playerPieceCount[p] = 0;
                        playerHighestValue[p] = 0;
                    });
                    
                    activePieces.forEach(p => {
                       playerPieceCount[p.player]++;
                       if(pieceValues[p.type] > playerHighestValue[p.player]){
                           playerHighestValue[p.player] = pieceValues[p.type];
                       }
                    });

                    let maxPieces = -1;
                    let playersWithMaxPieces = [];
                    activePlayers.forEach(p => {
                         if(playerPieceCount[p] > maxPieces){
                            maxPieces = playerPieceCount[p];
                            playersWithMaxPieces = [p];
                         } else if (playerPieceCount[p] === maxPieces) {
                            playersWithMaxPieces.push(p);
                         }
                    });

                    if(playersWithMaxPieces.length === 1) {
                         alert(`Stalemate! No more captures possible. Player ${playersWithMaxPieces[0]} wins with the most pieces!`);
                         location.reload();
                         return;
                    }

                    let maxValue = -1;
                    let winningPlayers = [];
                     playersWithMaxPieces.forEach(p => {
                        if(playerHighestValue[p] > maxValue) {
                            maxValue = playerHighestValue[p];
                            winningPlayers = [p];
                        } else if (playerHighestValue[p] === maxValue) {
                            winningPlayers.push(p);
                        }
                    });

                    if(winningPlayers.length === 1) {
                        alert(`Stalemate! No more captures possible. Player ${winningPlayers[0]} wins with the highest value piece!`);
                        location.reload();
                    } else {
                        alert("Stalemate! No more captures possible. It's a draw!");
                        location.reload();
                    }
                }
            }

            function playBotTurn() {
                const doBotAction = () => {
                    if (movesLeft <= 0 || !activePlayers.includes(2)) return;

                    const tryToMoveFromBase = () => {
                        const botPiecesInBase = players[2].filter(p => {
                            const pos = findPiecePosition(p.element);
                            return pos.onBoard === false && pos.inGraveyard === false;
                        });
                        if (botPiecesInBase.length > 0) {
                            const pieceToMove = botPiecesInBase[0];
                            const homeMainSquareId = getHomeMainSquareId(2);
                            const homeMainSquare = document.querySelector(`[data-main-square-id='${homeMainSquareId}']`);
                            const targetSubSquares = Array.from(homeMainSquare.children);
                            const validTargets = targetSubSquares.filter(square => !square.classList.contains('wall') && (!square.firstChild || canEat(pieceToMove, getPieceObject(square.firstChild))));

                            if (validTargets.length > 0) {
                                const targetSquare = validTargets[Math.floor(Math.random() * validTargets.length)];
                                movePiece(pieceToMove.element, parseInt(targetSquare.dataset.mainSquare), parseInt(targetSquare.dataset.subSquare));
                                return true;
                            }
                        }
                        return false;
                    };

                    const tryToMoveOnBoard = () => {
                        const botPiecesOnBoard = players[2].filter(p => findPiecePosition(p.element).onBoard === true);
                         if (botPiecesOnBoard.length > 0) {
                            const randomPiece = botPiecesOnBoard[Math.floor(Math.random() * botPiecesOnBoard.length)];
                            const allSubSquares = Array.from(document.querySelectorAll('.sub-square'));
                            const validMoves = allSubSquares.filter(sq => isValidMove(randomPiece, parseInt(sq.dataset.mainSquare), parseInt(sq.dataset.subSquare)));
                            const emptyValidMoves = validMoves.filter(sq => !sq.firstChild);

                            if (emptyValidMoves.length > 0) {
                                const targetSquare = emptyValidMoves[Math.floor(Math.random() * emptyValidMoves.length)];
                                movePiece(randomPiece.element, parseInt(targetSquare.dataset.mainSquare), parseInt(targetSquare.dataset.subSquare)); 
                                return true;
                            }
                        }
                        return false;
                    };

                    if (tryToMoveFromBase()) { return; }
                    if (tryToMoveOnBoard()) { return; }
                    
                    const allMainSquares = Array.from(document.querySelectorAll('.main-square'));
                    const randomMainSquare = allMainSquares[Math.floor(Math.random() * allMainSquares.length)];
                    rotateMainSquare(randomMainSquare);
                };

                setTimeout(() => {
                    doBotAction();
                    if (movesLeft > 0) {
                        setTimeout(() => {
                           doBotAction();
                        }, 800);
                    }
                }, 800);
            }
        });
    </script>

</body>
</html>
